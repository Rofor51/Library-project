{"ast":null,"code":"//Copyright 2014-2015 Google Inc. All rights reserved.\n//Use of this source code is governed by a BSD-style\n//license that can be found in the LICENSE file or at\n//https://developers.google.com/open-source/licenses/bsd\n\n/**\n * @fileoverview The U2F api.\n */\n'use strict';\n\n(function () {\n  if ('u2f' in window || !('chrome' in window)) {\n    return;\n  }\n  /** Namespace for the U2F api.\n   * @type {Object}\n   */\n\n\n  var u2f = window.u2f = {};\n  /**\n   * FIDO U2F Javascript API Version\n   * @number\n   */\n\n  var js_api_version;\n  /**\n   * The U2F extension id\n   * @const {string}\n   */\n  // The Chrome packaged app extension ID.\n  // Uncomment this if you want to deploy a server instance that uses\n  // the package Chrome app and does not require installing the U2F Chrome extension.\n\n  u2f.EXTENSION_ID = 'kmendfapggjehodndflmmgagdbamhnfd'; // The U2F Chrome extension ID.\n  // Uncomment this if you want to deploy a server instance that uses\n  // the U2F Chrome extension to authenticate.\n  // u2f.EXTENSION_ID = 'pfboblefjcgdjicmnffhdgionmgcdmne';\n\n  /**\n   * Message types for messsages to/from the extension\n   * @const\n   * @enum {string}\n   */\n\n  u2f.MessageTypes = {\n    'U2F_REGISTER_REQUEST': 'u2f_register_request',\n    'U2F_REGISTER_RESPONSE': 'u2f_register_response',\n    'U2F_SIGN_REQUEST': 'u2f_sign_request',\n    'U2F_SIGN_RESPONSE': 'u2f_sign_response',\n    'U2F_GET_API_VERSION_REQUEST': 'u2f_get_api_version_request',\n    'U2F_GET_API_VERSION_RESPONSE': 'u2f_get_api_version_response'\n  };\n  /**\n   * Response status codes\n   * @const\n   * @enum {number}\n   */\n\n  u2f.ErrorCodes = {\n    'OK': 0,\n    'OTHER_ERROR': 1,\n    'BAD_REQUEST': 2,\n    'CONFIGURATION_UNSUPPORTED': 3,\n    'DEVICE_INELIGIBLE': 4,\n    'TIMEOUT': 5\n  };\n  /**\n   * A message for registration requests\n   * @typedef {{\n   *   type: u2f.MessageTypes,\n   *   appId: ?string,\n   *   timeoutSeconds: ?number,\n   *   requestId: ?number\n   * }}\n   */\n\n  u2f.U2fRequest;\n  /**\n   * A message for registration responses\n   * @typedef {{\n   *   type: u2f.MessageTypes,\n   *   responseData: (u2f.Error | u2f.RegisterResponse | u2f.SignResponse),\n   *   requestId: ?number\n   * }}\n   */\n\n  u2f.U2fResponse;\n  /**\n   * An error object for responses\n   * @typedef {{\n   *   errorCode: u2f.ErrorCodes,\n   *   errorMessage: ?string\n   * }}\n   */\n\n  u2f.Error;\n  /**\n   * Data object for a single sign request.\n   * @typedef {enum {BLUETOOTH_RADIO, BLUETOOTH_LOW_ENERGY, USB, NFC}}\n   */\n\n  u2f.Transport;\n  /**\n   * Data object for a single sign request.\n   * @typedef {Array<u2f.Transport>}\n   */\n\n  u2f.Transports;\n  /**\n   * Data object for a single sign request.\n   * @typedef {{\n   *   version: string,\n   *   challenge: string,\n   *   keyHandle: string,\n   *   appId: string\n   * }}\n   */\n\n  u2f.SignRequest;\n  /**\n   * Data object for a sign response.\n   * @typedef {{\n   *   keyHandle: string,\n   *   signatureData: string,\n   *   clientData: string\n   * }}\n   */\n\n  u2f.SignResponse;\n  /**\n   * Data object for a registration request.\n   * @typedef {{\n   *   version: string,\n   *   challenge: string\n   * }}\n   */\n\n  u2f.RegisterRequest;\n  /**\n   * Data object for a registration response.\n   * @typedef {{\n   *   version: string,\n   *   keyHandle: string,\n   *   transports: Transports,\n   *   appId: string\n   * }}\n   */\n\n  u2f.RegisterResponse;\n  /**\n   * Data object for a registered key.\n   * @typedef {{\n   *   version: string,\n   *   keyHandle: string,\n   *   transports: ?Transports,\n   *   appId: ?string\n   * }}\n   */\n\n  u2f.RegisteredKey;\n  /**\n   * Data object for a get API register response.\n   * @typedef {{\n   *   js_api_version: number\n   * }}\n   */\n\n  u2f.GetJsApiVersionResponse; //Low level MessagePort API support\n\n  /**\n   * Sets up a MessagePort to the U2F extension using the\n   * available mechanisms.\n   * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback\n   */\n\n  u2f.getMessagePort = function (callback) {\n    if (typeof chrome != 'undefined' && chrome.runtime) {\n      // The actual message here does not matter, but we need to get a reply\n      // for the callback to run. Thus, send an empty signature request\n      // in order to get a failure response.\n      var msg = {\n        type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n        signRequests: []\n      };\n      chrome.runtime.sendMessage(u2f.EXTENSION_ID, msg, function () {\n        if (!chrome.runtime.lastError) {\n          // We are on a whitelisted origin and can talk directly\n          // with the extension.\n          u2f.getChromeRuntimePort_(callback);\n        } else {\n          // chrome.runtime was available, but we couldn't message\n          // the extension directly, use iframe\n          u2f.getIframePort_(callback);\n        }\n      });\n    } else if (u2f.isAndroidChrome_()) {\n      u2f.getAuthenticatorPort_(callback);\n    } else if (u2f.isIosChrome_()) {\n      u2f.getIosPort_(callback);\n    } else {\n      // chrome.runtime was not available at all, which is normal\n      // when this origin doesn't have access to any extensions.\n      u2f.getIframePort_(callback);\n    }\n  };\n  /**\n   * Detect chrome running on android based on the browser's useragent.\n   * @private\n   */\n\n\n  u2f.isAndroidChrome_ = function () {\n    var userAgent = navigator.userAgent;\n    return userAgent.indexOf('Chrome') != -1 && userAgent.indexOf('Android') != -1;\n  };\n  /**\n   * Detect chrome running on iOS based on the browser's platform.\n   * @private\n   */\n\n\n  u2f.isIosChrome_ = function () {\n    return $.inArray(navigator.platform, [\"iPhone\", \"iPad\", \"iPod\"]) > -1;\n  };\n  /**\n   * Connects directly to the extension via chrome.runtime.connect.\n   * @param {function(u2f.WrappedChromeRuntimePort_)} callback\n   * @private\n   */\n\n\n  u2f.getChromeRuntimePort_ = function (callback) {\n    var port = chrome.runtime.connect(u2f.EXTENSION_ID, {\n      'includeTlsChannelId': true\n    });\n    setTimeout(function () {\n      callback(new u2f.WrappedChromeRuntimePort_(port));\n    }, 0);\n  };\n  /**\n   * Return a 'port' abstraction to the Authenticator app.\n   * @param {function(u2f.WrappedAuthenticatorPort_)} callback\n   * @private\n   */\n\n\n  u2f.getAuthenticatorPort_ = function (callback) {\n    setTimeout(function () {\n      callback(new u2f.WrappedAuthenticatorPort_());\n    }, 0);\n  };\n  /**\n   * Return a 'port' abstraction to the iOS client app.\n   * @param {function(u2f.WrappedIosPort_)} callback\n   * @private\n   */\n\n\n  u2f.getIosPort_ = function (callback) {\n    setTimeout(function () {\n      callback(new u2f.WrappedIosPort_());\n    }, 0);\n  };\n  /**\n   * A wrapper for chrome.runtime.Port that is compatible with MessagePort.\n   * @param {Port} port\n   * @constructor\n   * @private\n   */\n\n\n  u2f.WrappedChromeRuntimePort_ = function (port) {\n    this.port_ = port;\n  };\n  /**\n   * Format and return a sign request compliant with the JS API version supported by the extension.\n   * @param {Array<u2f.SignRequest>} signRequests\n   * @param {number} timeoutSeconds\n   * @param {number} reqId\n   * @return {Object}\n   */\n\n\n  u2f.formatSignRequest_ = function (appId, challenge, registeredKeys, timeoutSeconds, reqId) {\n    if (js_api_version === undefined || js_api_version < 1.1) {\n      // Adapt request to the 1.0 JS API\n      var signRequests = [];\n\n      for (var i = 0; i < registeredKeys.length; i++) {\n        signRequests[i] = {\n          version: registeredKeys[i].version,\n          challenge: challenge,\n          keyHandle: registeredKeys[i].keyHandle,\n          appId: appId\n        };\n      }\n\n      return {\n        type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n        signRequests: signRequests,\n        timeoutSeconds: timeoutSeconds,\n        requestId: reqId\n      };\n    } // JS 1.1 API\n\n\n    return {\n      type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n      appId: appId,\n      challenge: challenge,\n      registeredKeys: registeredKeys,\n      timeoutSeconds: timeoutSeconds,\n      requestId: reqId\n    };\n  };\n  /**\n   * Format and return a register request compliant with the JS API version supported by the extension..\n   * @param {Array<u2f.SignRequest>} signRequests\n   * @param {Array<u2f.RegisterRequest>} signRequests\n   * @param {number} timeoutSeconds\n   * @param {number} reqId\n   * @return {Object}\n   */\n\n\n  u2f.formatRegisterRequest_ = function (appId, registeredKeys, registerRequests, timeoutSeconds, reqId) {\n    if (js_api_version === undefined || js_api_version < 1.1) {\n      // Adapt request to the 1.0 JS API\n      for (var i = 0; i < registerRequests.length; i++) {\n        registerRequests[i].appId = appId;\n      }\n\n      var signRequests = [];\n\n      for (var i = 0; i < registeredKeys.length; i++) {\n        signRequests[i] = {\n          version: registeredKeys[i].version,\n          challenge: registerRequests[0],\n          keyHandle: registeredKeys[i].keyHandle,\n          appId: appId\n        };\n      }\n\n      return {\n        type: u2f.MessageTypes.U2F_REGISTER_REQUEST,\n        signRequests: signRequests,\n        registerRequests: registerRequests,\n        timeoutSeconds: timeoutSeconds,\n        requestId: reqId\n      };\n    } // JS 1.1 API\n\n\n    return {\n      type: u2f.MessageTypes.U2F_REGISTER_REQUEST,\n      appId: appId,\n      registerRequests: registerRequests,\n      registeredKeys: registeredKeys,\n      timeoutSeconds: timeoutSeconds,\n      requestId: reqId\n    };\n  };\n  /**\n   * Posts a message on the underlying channel.\n   * @param {Object} message\n   */\n\n\n  u2f.WrappedChromeRuntimePort_.prototype.postMessage = function (message) {\n    this.port_.postMessage(message);\n  };\n  /**\n   * Emulates the HTML 5 addEventListener interface. Works only for the\n   * onmessage event, which is hooked up to the chrome.runtime.Port.onMessage.\n   * @param {string} eventName\n   * @param {function({data: Object})} handler\n   */\n\n\n  u2f.WrappedChromeRuntimePort_.prototype.addEventListener = function (eventName, handler) {\n    var name = eventName.toLowerCase();\n\n    if (name == 'message' || name == 'onmessage') {\n      this.port_.onMessage.addListener(function (message) {\n        // Emulate a minimal MessageEvent object\n        handler({\n          'data': message\n        });\n      });\n    } else {\n      console.error('WrappedChromeRuntimePort only supports onMessage');\n    }\n  };\n  /**\n   * Wrap the Authenticator app with a MessagePort interface.\n   * @constructor\n   * @private\n   */\n\n\n  u2f.WrappedAuthenticatorPort_ = function () {\n    this.requestId_ = -1;\n    this.requestObject_ = null;\n  };\n  /**\n   * Launch the Authenticator intent.\n   * @param {Object} message\n   */\n\n\n  u2f.WrappedAuthenticatorPort_.prototype.postMessage = function (message) {\n    var intentUrl = u2f.WrappedAuthenticatorPort_.INTENT_URL_BASE_ + ';S.request=' + encodeURIComponent(JSON.stringify(message)) + ';end';\n    document.location = intentUrl;\n  };\n  /**\n   * Tells what type of port this is.\n   * @return {String} port type\n   */\n\n\n  u2f.WrappedAuthenticatorPort_.prototype.getPortType = function () {\n    return \"WrappedAuthenticatorPort_\";\n  };\n  /**\n   * Emulates the HTML 5 addEventListener interface.\n   * @param {string} eventName\n   * @param {function({data: Object})} handler\n   */\n\n\n  u2f.WrappedAuthenticatorPort_.prototype.addEventListener = function (eventName, handler) {\n    var name = eventName.toLowerCase();\n\n    if (name == 'message') {\n      var self = this;\n      /* Register a callback to that executes when\n       * chrome injects the response. */\n\n      window.addEventListener('message', self.onRequestUpdate_.bind(self, handler), false);\n    } else {\n      console.error('WrappedAuthenticatorPort only supports message');\n    }\n  };\n  /**\n   * Callback invoked  when a response is received from the Authenticator.\n   * @param function({data: Object}) callback\n   * @param {Object} message message Object\n   */\n\n\n  u2f.WrappedAuthenticatorPort_.prototype.onRequestUpdate_ = function (callback, message) {\n    var messageObject = JSON.parse(message.data);\n    var intentUrl = messageObject['intentURL'];\n    var errorCode = messageObject['errorCode'];\n    var responseObject = null;\n\n    if (messageObject.hasOwnProperty('data')) {\n      responseObject =\n      /** @type {Object} */\n      JSON.parse(messageObject['data']);\n    }\n\n    callback({\n      'data': responseObject\n    });\n  };\n  /**\n   * Base URL for intents to Authenticator.\n   * @const\n   * @private\n   */\n\n\n  u2f.WrappedAuthenticatorPort_.INTENT_URL_BASE_ = 'intent:#Intent;action=com.google.android.apps.authenticator.AUTHENTICATE';\n  /**\n   * Wrap the iOS client app with a MessagePort interface.\n   * @constructor\n   * @private\n   */\n\n  u2f.WrappedIosPort_ = function () {};\n  /**\n   * Launch the iOS client app request\n   * @param {Object} message\n   */\n\n\n  u2f.WrappedIosPort_.prototype.postMessage = function (message) {\n    var str = JSON.stringify(message);\n    var url = \"u2f://auth?\" + encodeURI(str);\n    location.replace(url);\n  };\n  /**\n   * Tells what type of port this is.\n   * @return {String} port type\n   */\n\n\n  u2f.WrappedIosPort_.prototype.getPortType = function () {\n    return \"WrappedIosPort_\";\n  };\n  /**\n   * Emulates the HTML 5 addEventListener interface.\n   * @param {string} eventName\n   * @param {function({data: Object})} handler\n   */\n\n\n  u2f.WrappedIosPort_.prototype.addEventListener = function (eventName, handler) {\n    var name = eventName.toLowerCase();\n\n    if (name !== 'message') {\n      console.error('WrappedIosPort only supports message');\n    }\n  };\n  /**\n   * Sets up an embedded trampoline iframe, sourced from the extension.\n   * @param {function(MessagePort)} callback\n   * @private\n   */\n\n\n  u2f.getIframePort_ = function (callback) {\n    // Create the iframe\n    var iframeOrigin = 'chrome-extension://' + u2f.EXTENSION_ID;\n    var iframe = document.createElement('iframe');\n    iframe.src = iframeOrigin + '/u2f-comms.html';\n    iframe.setAttribute('style', 'display:none');\n    document.body.appendChild(iframe);\n    var channel = new MessageChannel();\n\n    var ready = function (message) {\n      if (message.data == 'ready') {\n        channel.port1.removeEventListener('message', ready);\n        callback(channel.port1);\n      } else {\n        console.error('First event on iframe port was not \"ready\"');\n      }\n    };\n\n    channel.port1.addEventListener('message', ready);\n    channel.port1.start();\n    iframe.addEventListener('load', function () {\n      // Deliver the port to the iframe and initialize\n      iframe.contentWindow.postMessage('init', iframeOrigin, [channel.port2]);\n    });\n  }; //High-level JS API\n\n  /**\n   * Default extension response timeout in seconds.\n   * @const\n   */\n\n\n  u2f.EXTENSION_TIMEOUT_SEC = 30;\n  /**\n   * A singleton instance for a MessagePort to the extension.\n   * @type {MessagePort|u2f.WrappedChromeRuntimePort_}\n   * @private\n   */\n\n  u2f.port_ = null;\n  /**\n   * Callbacks waiting for a port\n   * @type {Array<function((MessagePort|u2f.WrappedChromeRuntimePort_))>}\n   * @private\n   */\n\n  u2f.waitingForPort_ = [];\n  /**\n   * A counter for requestIds.\n   * @type {number}\n   * @private\n   */\n\n  u2f.reqCounter_ = 0;\n  /**\n   * A map from requestIds to client callbacks\n   * @type {Object.<number,(function((u2f.Error|u2f.RegisterResponse))\n   *                       |function((u2f.Error|u2f.SignResponse)))>}\n   * @private\n   */\n\n  u2f.callbackMap_ = {};\n  /**\n   * Creates or retrieves the MessagePort singleton to use.\n   * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback\n   * @private\n   */\n\n  u2f.getPortSingleton_ = function (callback) {\n    if (u2f.port_) {\n      callback(u2f.port_);\n    } else {\n      if (u2f.waitingForPort_.length == 0) {\n        u2f.getMessagePort(function (port) {\n          u2f.port_ = port;\n          u2f.port_.addEventListener('message',\n          /** @type {function(Event)} */\n          u2f.responseHandler_); // Careful, here be async callbacks. Maybe.\n\n          while (u2f.waitingForPort_.length) u2f.waitingForPort_.shift()(u2f.port_);\n        });\n      }\n\n      u2f.waitingForPort_.push(callback);\n    }\n  };\n  /**\n   * Handles response messages from the extension.\n   * @param {MessageEvent.<u2f.Response>} message\n   * @private\n   */\n\n\n  u2f.responseHandler_ = function (message) {\n    var response = message.data;\n    var reqId = response['requestId'];\n\n    if (!reqId || !u2f.callbackMap_[reqId]) {\n      console.error('Unknown or missing requestId in response.');\n      return;\n    }\n\n    var cb = u2f.callbackMap_[reqId];\n    delete u2f.callbackMap_[reqId];\n    cb(response['responseData']);\n  };\n  /**\n   * Dispatches an array of sign requests to available U2F tokens.\n   * If the JS API version supported by the extension is unknown, it first sends a\n   * message to the extension to find out the supported API version and then it sends\n   * the sign request.\n   * @param {string=} appId\n   * @param {string=} challenge\n   * @param {Array<u2f.RegisteredKey>} registeredKeys\n   * @param {function((u2f.Error|u2f.SignResponse))} callback\n   * @param {number=} opt_timeoutSeconds\n   */\n\n\n  u2f.sign = function (appId, challenge, registeredKeys, callback, opt_timeoutSeconds) {\n    if (js_api_version === undefined) {\n      // Send a message to get the extension to JS API version, then send the actual sign request.\n      u2f.getApiVersion(function (response) {\n        js_api_version = response['js_api_version'] === undefined ? 0 : response['js_api_version'];\n        console.log(\"Extension JS API Version: \", js_api_version);\n        u2f.sendSignRequest(appId, challenge, registeredKeys, callback, opt_timeoutSeconds);\n      });\n    } else {\n      // We know the JS API version. Send the actual sign request in the supported API version.\n      u2f.sendSignRequest(appId, challenge, registeredKeys, callback, opt_timeoutSeconds);\n    }\n  };\n  /**\n   * Dispatches an array of sign requests to available U2F tokens.\n   * @param {string=} appId\n   * @param {string=} challenge\n   * @param {Array<u2f.RegisteredKey>} registeredKeys\n   * @param {function((u2f.Error|u2f.SignResponse))} callback\n   * @param {number=} opt_timeoutSeconds\n   */\n\n\n  u2f.sendSignRequest = function (appId, challenge, registeredKeys, callback, opt_timeoutSeconds) {\n    u2f.getPortSingleton_(function (port) {\n      var reqId = ++u2f.reqCounter_;\n      u2f.callbackMap_[reqId] = callback;\n      var timeoutSeconds = typeof opt_timeoutSeconds !== 'undefined' ? opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC;\n      var req = u2f.formatSignRequest_(appId, challenge, registeredKeys, timeoutSeconds, reqId);\n      port.postMessage(req);\n    });\n  };\n  /**\n   * Dispatches register requests to available U2F tokens. An array of sign\n   * requests identifies already registered tokens.\n   * If the JS API version supported by the extension is unknown, it first sends a\n   * message to the extension to find out the supported API version and then it sends\n   * the register request.\n   * @param {string=} appId\n   * @param {Array<u2f.RegisterRequest>} registerRequests\n   * @param {Array<u2f.RegisteredKey>} registeredKeys\n   * @param {function((u2f.Error|u2f.RegisterResponse))} callback\n   * @param {number=} opt_timeoutSeconds\n   */\n\n\n  u2f.register = function (appId, registerRequests, registeredKeys, callback, opt_timeoutSeconds) {\n    if (js_api_version === undefined) {\n      // Send a message to get the extension to JS API version, then send the actual register request.\n      u2f.getApiVersion(function (response) {\n        js_api_version = response['js_api_version'] === undefined ? 0 : response['js_api_version'];\n        console.log(\"Extension JS API Version: \", js_api_version);\n        u2f.sendRegisterRequest(appId, registerRequests, registeredKeys, callback, opt_timeoutSeconds);\n      });\n    } else {\n      // We know the JS API version. Send the actual register request in the supported API version.\n      u2f.sendRegisterRequest(appId, registerRequests, registeredKeys, callback, opt_timeoutSeconds);\n    }\n  };\n  /**\n   * Dispatches register requests to available U2F tokens. An array of sign\n   * requests identifies already registered tokens.\n   * @param {string=} appId\n   * @param {Array<u2f.RegisterRequest>} registerRequests\n   * @param {Array<u2f.RegisteredKey>} registeredKeys\n   * @param {function((u2f.Error|u2f.RegisterResponse))} callback\n   * @param {number=} opt_timeoutSeconds\n   */\n\n\n  u2f.sendRegisterRequest = function (appId, registerRequests, registeredKeys, callback, opt_timeoutSeconds) {\n    u2f.getPortSingleton_(function (port) {\n      var reqId = ++u2f.reqCounter_;\n      u2f.callbackMap_[reqId] = callback;\n      var timeoutSeconds = typeof opt_timeoutSeconds !== 'undefined' ? opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC;\n      var req = u2f.formatRegisterRequest_(appId, registeredKeys, registerRequests, timeoutSeconds, reqId);\n      port.postMessage(req);\n    });\n  };\n  /**\n   * Dispatches a message to the extension to find out the supported\n   * JS API version.\n   * If the user is on a mobile phone and is thus using Google Authenticator instead\n   * of the Chrome extension, don't send the request and simply return 0.\n   * @param {function((u2f.Error|u2f.GetJsApiVersionResponse))} callback\n   * @param {number=} opt_timeoutSeconds\n   */\n\n\n  u2f.getApiVersion = function (callback, opt_timeoutSeconds) {\n    u2f.getPortSingleton_(function (port) {\n      // If we are using Android Google Authenticator or iOS client app,\n      // do not fire an intent to ask which JS API version to use.\n      if (port.getPortType) {\n        var apiVersion;\n\n        switch (port.getPortType()) {\n          case 'WrappedIosPort_':\n          case 'WrappedAuthenticatorPort_':\n            apiVersion = 1.1;\n            break;\n\n          default:\n            apiVersion = 0;\n            break;\n        }\n\n        callback({\n          'js_api_version': apiVersion\n        });\n        return;\n      }\n\n      var reqId = ++u2f.reqCounter_;\n      u2f.callbackMap_[reqId] = callback;\n      var req = {\n        type: u2f.MessageTypes.U2F_GET_API_VERSION_REQUEST,\n        timeoutSeconds: typeof opt_timeoutSeconds !== 'undefined' ? opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC,\n        requestId: reqId\n      };\n      port.postMessage(req);\n    });\n  };\n})();","map":{"version":3,"sources":["C:/Users/robin/Desktop/sso/my-app/node_modules/u2f-api-polyfill/u2f-api-polyfill.js"],"names":["window","u2f","js_api_version","EXTENSION_ID","MessageTypes","ErrorCodes","U2fRequest","U2fResponse","Error","Transport","Transports","SignRequest","SignResponse","RegisterRequest","RegisterResponse","RegisteredKey","GetJsApiVersionResponse","getMessagePort","callback","chrome","runtime","msg","type","U2F_SIGN_REQUEST","signRequests","sendMessage","lastError","getChromeRuntimePort_","getIframePort_","isAndroidChrome_","getAuthenticatorPort_","isIosChrome_","getIosPort_","userAgent","navigator","indexOf","$","inArray","platform","port","connect","setTimeout","WrappedChromeRuntimePort_","WrappedAuthenticatorPort_","WrappedIosPort_","port_","formatSignRequest_","appId","challenge","registeredKeys","timeoutSeconds","reqId","undefined","i","length","version","keyHandle","requestId","formatRegisterRequest_","registerRequests","U2F_REGISTER_REQUEST","prototype","postMessage","message","addEventListener","eventName","handler","name","toLowerCase","onMessage","addListener","console","error","requestId_","requestObject_","intentUrl","INTENT_URL_BASE_","encodeURIComponent","JSON","stringify","document","location","getPortType","self","onRequestUpdate_","bind","messageObject","parse","data","errorCode","responseObject","hasOwnProperty","str","url","encodeURI","replace","iframeOrigin","iframe","createElement","src","setAttribute","body","appendChild","channel","MessageChannel","ready","port1","removeEventListener","start","contentWindow","port2","EXTENSION_TIMEOUT_SEC","waitingForPort_","reqCounter_","callbackMap_","getPortSingleton_","responseHandler_","shift","push","response","cb","sign","opt_timeoutSeconds","getApiVersion","log","sendSignRequest","req","register","sendRegisterRequest","apiVersion","U2F_GET_API_VERSION_REQUEST"],"mappings":"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","sourcesContent":["\n//Copyright 2014-2015 Google Inc. All rights reserved.\n\n//Use of this source code is governed by a BSD-style\n//license that can be found in the LICENSE file or at\n//https://developers.google.com/open-source/licenses/bsd\n\n/**\n * @fileoverview The U2F api.\n */\n'use strict';\n\n(function (){\n  if ('u2f' in window || !('chrome' in window)) {\n    return;\n  }\n\n  /** Namespace for the U2F api.\n   * @type {Object}\n   */\n  var u2f = window.u2f = {};\n\n  /**\n   * FIDO U2F Javascript API Version\n   * @number\n   */\n  var js_api_version;\n\n  /**\n   * The U2F extension id\n   * @const {string}\n   */\n  // The Chrome packaged app extension ID.\n  // Uncomment this if you want to deploy a server instance that uses\n  // the package Chrome app and does not require installing the U2F Chrome extension.\n   u2f.EXTENSION_ID = 'kmendfapggjehodndflmmgagdbamhnfd';\n  // The U2F Chrome extension ID.\n  // Uncomment this if you want to deploy a server instance that uses\n  // the U2F Chrome extension to authenticate.\n  // u2f.EXTENSION_ID = 'pfboblefjcgdjicmnffhdgionmgcdmne';\n\n\n  /**\n   * Message types for messsages to/from the extension\n   * @const\n   * @enum {string}\n   */\n  u2f.MessageTypes = {\n      'U2F_REGISTER_REQUEST': 'u2f_register_request',\n      'U2F_REGISTER_RESPONSE': 'u2f_register_response',\n      'U2F_SIGN_REQUEST': 'u2f_sign_request',\n      'U2F_SIGN_RESPONSE': 'u2f_sign_response',\n      'U2F_GET_API_VERSION_REQUEST': 'u2f_get_api_version_request',\n      'U2F_GET_API_VERSION_RESPONSE': 'u2f_get_api_version_response'\n  };\n\n\n  /**\n   * Response status codes\n   * @const\n   * @enum {number}\n   */\n  u2f.ErrorCodes = {\n      'OK': 0,\n      'OTHER_ERROR': 1,\n      'BAD_REQUEST': 2,\n      'CONFIGURATION_UNSUPPORTED': 3,\n      'DEVICE_INELIGIBLE': 4,\n      'TIMEOUT': 5\n  };\n\n\n  /**\n   * A message for registration requests\n   * @typedef {{\n   *   type: u2f.MessageTypes,\n   *   appId: ?string,\n   *   timeoutSeconds: ?number,\n   *   requestId: ?number\n   * }}\n   */\n  u2f.U2fRequest;\n\n\n  /**\n   * A message for registration responses\n   * @typedef {{\n   *   type: u2f.MessageTypes,\n   *   responseData: (u2f.Error | u2f.RegisterResponse | u2f.SignResponse),\n   *   requestId: ?number\n   * }}\n   */\n  u2f.U2fResponse;\n\n\n  /**\n   * An error object for responses\n   * @typedef {{\n   *   errorCode: u2f.ErrorCodes,\n   *   errorMessage: ?string\n   * }}\n   */\n  u2f.Error;\n\n  /**\n   * Data object for a single sign request.\n   * @typedef {enum {BLUETOOTH_RADIO, BLUETOOTH_LOW_ENERGY, USB, NFC}}\n   */\n  u2f.Transport;\n\n\n  /**\n   * Data object for a single sign request.\n   * @typedef {Array<u2f.Transport>}\n   */\n  u2f.Transports;\n\n  /**\n   * Data object for a single sign request.\n   * @typedef {{\n   *   version: string,\n   *   challenge: string,\n   *   keyHandle: string,\n   *   appId: string\n   * }}\n   */\n  u2f.SignRequest;\n\n\n  /**\n   * Data object for a sign response.\n   * @typedef {{\n   *   keyHandle: string,\n   *   signatureData: string,\n   *   clientData: string\n   * }}\n   */\n  u2f.SignResponse;\n\n\n  /**\n   * Data object for a registration request.\n   * @typedef {{\n   *   version: string,\n   *   challenge: string\n   * }}\n   */\n  u2f.RegisterRequest;\n\n\n  /**\n   * Data object for a registration response.\n   * @typedef {{\n   *   version: string,\n   *   keyHandle: string,\n   *   transports: Transports,\n   *   appId: string\n   * }}\n   */\n  u2f.RegisterResponse;\n\n\n  /**\n   * Data object for a registered key.\n   * @typedef {{\n   *   version: string,\n   *   keyHandle: string,\n   *   transports: ?Transports,\n   *   appId: ?string\n   * }}\n   */\n  u2f.RegisteredKey;\n\n\n  /**\n   * Data object for a get API register response.\n   * @typedef {{\n   *   js_api_version: number\n   * }}\n   */\n  u2f.GetJsApiVersionResponse;\n\n\n  //Low level MessagePort API support\n\n  /**\n   * Sets up a MessagePort to the U2F extension using the\n   * available mechanisms.\n   * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback\n   */\n  u2f.getMessagePort = function(callback) {\n    if (typeof chrome != 'undefined' && chrome.runtime) {\n      // The actual message here does not matter, but we need to get a reply\n      // for the callback to run. Thus, send an empty signature request\n      // in order to get a failure response.\n      var msg = {\n          type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n          signRequests: []\n      };\n      chrome.runtime.sendMessage(u2f.EXTENSION_ID, msg, function() {\n        if (!chrome.runtime.lastError) {\n          // We are on a whitelisted origin and can talk directly\n          // with the extension.\n          u2f.getChromeRuntimePort_(callback);\n        } else {\n          // chrome.runtime was available, but we couldn't message\n          // the extension directly, use iframe\n          u2f.getIframePort_(callback);\n        }\n      });\n    } else if (u2f.isAndroidChrome_()) {\n      u2f.getAuthenticatorPort_(callback);\n    } else if (u2f.isIosChrome_()) {\n      u2f.getIosPort_(callback);\n    } else {\n      // chrome.runtime was not available at all, which is normal\n      // when this origin doesn't have access to any extensions.\n      u2f.getIframePort_(callback);\n    }\n  };\n\n  /**\n   * Detect chrome running on android based on the browser's useragent.\n   * @private\n   */\n  u2f.isAndroidChrome_ = function() {\n    var userAgent = navigator.userAgent;\n    return userAgent.indexOf('Chrome') != -1 &&\n    userAgent.indexOf('Android') != -1;\n  };\n\n  /**\n   * Detect chrome running on iOS based on the browser's platform.\n   * @private\n   */\n  u2f.isIosChrome_ = function() {\n    return $.inArray(navigator.platform, [\"iPhone\", \"iPad\", \"iPod\"]) > -1;\n  };\n\n  /**\n   * Connects directly to the extension via chrome.runtime.connect.\n   * @param {function(u2f.WrappedChromeRuntimePort_)} callback\n   * @private\n   */\n  u2f.getChromeRuntimePort_ = function(callback) {\n    var port = chrome.runtime.connect(u2f.EXTENSION_ID,\n        {'includeTlsChannelId': true});\n    setTimeout(function() {\n      callback(new u2f.WrappedChromeRuntimePort_(port));\n    }, 0);\n  };\n\n  /**\n   * Return a 'port' abstraction to the Authenticator app.\n   * @param {function(u2f.WrappedAuthenticatorPort_)} callback\n   * @private\n   */\n  u2f.getAuthenticatorPort_ = function(callback) {\n    setTimeout(function() {\n      callback(new u2f.WrappedAuthenticatorPort_());\n    }, 0);\n  };\n\n  /**\n   * Return a 'port' abstraction to the iOS client app.\n   * @param {function(u2f.WrappedIosPort_)} callback\n   * @private\n   */\n  u2f.getIosPort_ = function(callback) {\n    setTimeout(function() {\n      callback(new u2f.WrappedIosPort_());\n    }, 0);\n  };\n\n  /**\n   * A wrapper for chrome.runtime.Port that is compatible with MessagePort.\n   * @param {Port} port\n   * @constructor\n   * @private\n   */\n  u2f.WrappedChromeRuntimePort_ = function(port) {\n    this.port_ = port;\n  };\n\n  /**\n   * Format and return a sign request compliant with the JS API version supported by the extension.\n   * @param {Array<u2f.SignRequest>} signRequests\n   * @param {number} timeoutSeconds\n   * @param {number} reqId\n   * @return {Object}\n   */\n  u2f.formatSignRequest_ =\n    function(appId, challenge, registeredKeys, timeoutSeconds, reqId) {\n    if (js_api_version === undefined || js_api_version < 1.1) {\n      // Adapt request to the 1.0 JS API\n      var signRequests = [];\n      for (var i = 0; i < registeredKeys.length; i++) {\n        signRequests[i] = {\n            version: registeredKeys[i].version,\n            challenge: challenge,\n            keyHandle: registeredKeys[i].keyHandle,\n            appId: appId\n        };\n      }\n      return {\n        type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n        signRequests: signRequests,\n        timeoutSeconds: timeoutSeconds,\n        requestId: reqId\n      };\n    }\n    // JS 1.1 API\n    return {\n      type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n      appId: appId,\n      challenge: challenge,\n      registeredKeys: registeredKeys,\n      timeoutSeconds: timeoutSeconds,\n      requestId: reqId\n    };\n  };\n\n  /**\n   * Format and return a register request compliant with the JS API version supported by the extension..\n   * @param {Array<u2f.SignRequest>} signRequests\n   * @param {Array<u2f.RegisterRequest>} signRequests\n   * @param {number} timeoutSeconds\n   * @param {number} reqId\n   * @return {Object}\n   */\n  u2f.formatRegisterRequest_ =\n    function(appId, registeredKeys, registerRequests, timeoutSeconds, reqId) {\n    if (js_api_version === undefined || js_api_version < 1.1) {\n      // Adapt request to the 1.0 JS API\n      for (var i = 0; i < registerRequests.length; i++) {\n        registerRequests[i].appId = appId;\n      }\n      var signRequests = [];\n      for (var i = 0; i < registeredKeys.length; i++) {\n        signRequests[i] = {\n            version: registeredKeys[i].version,\n            challenge: registerRequests[0],\n            keyHandle: registeredKeys[i].keyHandle,\n            appId: appId\n        };\n      }\n      return {\n        type: u2f.MessageTypes.U2F_REGISTER_REQUEST,\n        signRequests: signRequests,\n        registerRequests: registerRequests,\n        timeoutSeconds: timeoutSeconds,\n        requestId: reqId\n      };\n    }\n    // JS 1.1 API\n    return {\n      type: u2f.MessageTypes.U2F_REGISTER_REQUEST,\n      appId: appId,\n      registerRequests: registerRequests,\n      registeredKeys: registeredKeys,\n      timeoutSeconds: timeoutSeconds,\n      requestId: reqId\n    };\n  };\n\n\n  /**\n   * Posts a message on the underlying channel.\n   * @param {Object} message\n   */\n  u2f.WrappedChromeRuntimePort_.prototype.postMessage = function(message) {\n    this.port_.postMessage(message);\n  };\n\n\n  /**\n   * Emulates the HTML 5 addEventListener interface. Works only for the\n   * onmessage event, which is hooked up to the chrome.runtime.Port.onMessage.\n   * @param {string} eventName\n   * @param {function({data: Object})} handler\n   */\n  u2f.WrappedChromeRuntimePort_.prototype.addEventListener =\n      function(eventName, handler) {\n    var name = eventName.toLowerCase();\n    if (name == 'message' || name == 'onmessage') {\n      this.port_.onMessage.addListener(function(message) {\n        // Emulate a minimal MessageEvent object\n        handler({'data': message});\n      });\n    } else {\n      console.error('WrappedChromeRuntimePort only supports onMessage');\n    }\n  };\n\n  /**\n   * Wrap the Authenticator app with a MessagePort interface.\n   * @constructor\n   * @private\n   */\n  u2f.WrappedAuthenticatorPort_ = function() {\n    this.requestId_ = -1;\n    this.requestObject_ = null;\n  }\n\n  /**\n   * Launch the Authenticator intent.\n   * @param {Object} message\n   */\n  u2f.WrappedAuthenticatorPort_.prototype.postMessage = function(message) {\n    var intentUrl =\n      u2f.WrappedAuthenticatorPort_.INTENT_URL_BASE_ +\n      ';S.request=' + encodeURIComponent(JSON.stringify(message)) +\n      ';end';\n    document.location = intentUrl;\n  };\n\n  /**\n   * Tells what type of port this is.\n   * @return {String} port type\n   */\n  u2f.WrappedAuthenticatorPort_.prototype.getPortType = function() {\n    return \"WrappedAuthenticatorPort_\";\n  };\n\n\n  /**\n   * Emulates the HTML 5 addEventListener interface.\n   * @param {string} eventName\n   * @param {function({data: Object})} handler\n   */\n  u2f.WrappedAuthenticatorPort_.prototype.addEventListener = function(eventName, handler) {\n    var name = eventName.toLowerCase();\n    if (name == 'message') {\n      var self = this;\n      /* Register a callback to that executes when\n       * chrome injects the response. */\n      window.addEventListener(\n          'message', self.onRequestUpdate_.bind(self, handler), false);\n    } else {\n      console.error('WrappedAuthenticatorPort only supports message');\n    }\n  };\n\n  /**\n   * Callback invoked  when a response is received from the Authenticator.\n   * @param function({data: Object}) callback\n   * @param {Object} message message Object\n   */\n  u2f.WrappedAuthenticatorPort_.prototype.onRequestUpdate_ =\n      function(callback, message) {\n    var messageObject = JSON.parse(message.data);\n    var intentUrl = messageObject['intentURL'];\n\n    var errorCode = messageObject['errorCode'];\n    var responseObject = null;\n    if (messageObject.hasOwnProperty('data')) {\n      responseObject = /** @type {Object} */ (\n          JSON.parse(messageObject['data']));\n    }\n\n    callback({'data': responseObject});\n  };\n\n  /**\n   * Base URL for intents to Authenticator.\n   * @const\n   * @private\n   */\n  u2f.WrappedAuthenticatorPort_.INTENT_URL_BASE_ =\n    'intent:#Intent;action=com.google.android.apps.authenticator.AUTHENTICATE';\n\n  /**\n   * Wrap the iOS client app with a MessagePort interface.\n   * @constructor\n   * @private\n   */\n  u2f.WrappedIosPort_ = function() {};\n\n  /**\n   * Launch the iOS client app request\n   * @param {Object} message\n   */\n  u2f.WrappedIosPort_.prototype.postMessage = function(message) {\n    var str = JSON.stringify(message);\n    var url = \"u2f://auth?\" + encodeURI(str);\n    location.replace(url);\n  };\n\n  /**\n   * Tells what type of port this is.\n   * @return {String} port type\n   */\n  u2f.WrappedIosPort_.prototype.getPortType = function() {\n    return \"WrappedIosPort_\";\n  };\n\n  /**\n   * Emulates the HTML 5 addEventListener interface.\n   * @param {string} eventName\n   * @param {function({data: Object})} handler\n   */\n  u2f.WrappedIosPort_.prototype.addEventListener = function(eventName, handler) {\n    var name = eventName.toLowerCase();\n    if (name !== 'message') {\n      console.error('WrappedIosPort only supports message');\n    }\n  };\n\n  /**\n   * Sets up an embedded trampoline iframe, sourced from the extension.\n   * @param {function(MessagePort)} callback\n   * @private\n   */\n  u2f.getIframePort_ = function(callback) {\n    // Create the iframe\n    var iframeOrigin = 'chrome-extension://' + u2f.EXTENSION_ID;\n    var iframe = document.createElement('iframe');\n    iframe.src = iframeOrigin + '/u2f-comms.html';\n    iframe.setAttribute('style', 'display:none');\n    document.body.appendChild(iframe);\n\n    var channel = new MessageChannel();\n    var ready = function(message) {\n      if (message.data == 'ready') {\n        channel.port1.removeEventListener('message', ready);\n        callback(channel.port1);\n      } else {\n        console.error('First event on iframe port was not \"ready\"');\n      }\n    };\n    channel.port1.addEventListener('message', ready);\n    channel.port1.start();\n\n    iframe.addEventListener('load', function() {\n      // Deliver the port to the iframe and initialize\n      iframe.contentWindow.postMessage('init', iframeOrigin, [channel.port2]);\n    });\n  };\n\n\n  //High-level JS API\n\n  /**\n   * Default extension response timeout in seconds.\n   * @const\n   */\n  u2f.EXTENSION_TIMEOUT_SEC = 30;\n\n  /**\n   * A singleton instance for a MessagePort to the extension.\n   * @type {MessagePort|u2f.WrappedChromeRuntimePort_}\n   * @private\n   */\n  u2f.port_ = null;\n\n  /**\n   * Callbacks waiting for a port\n   * @type {Array<function((MessagePort|u2f.WrappedChromeRuntimePort_))>}\n   * @private\n   */\n  u2f.waitingForPort_ = [];\n\n  /**\n   * A counter for requestIds.\n   * @type {number}\n   * @private\n   */\n  u2f.reqCounter_ = 0;\n\n  /**\n   * A map from requestIds to client callbacks\n   * @type {Object.<number,(function((u2f.Error|u2f.RegisterResponse))\n   *                       |function((u2f.Error|u2f.SignResponse)))>}\n   * @private\n   */\n  u2f.callbackMap_ = {};\n\n  /**\n   * Creates or retrieves the MessagePort singleton to use.\n   * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback\n   * @private\n   */\n  u2f.getPortSingleton_ = function(callback) {\n    if (u2f.port_) {\n      callback(u2f.port_);\n    } else {\n      if (u2f.waitingForPort_.length == 0) {\n        u2f.getMessagePort(function(port) {\n          u2f.port_ = port;\n          u2f.port_.addEventListener('message',\n              /** @type {function(Event)} */ (u2f.responseHandler_));\n\n          // Careful, here be async callbacks. Maybe.\n          while (u2f.waitingForPort_.length)\n            u2f.waitingForPort_.shift()(u2f.port_);\n        });\n      }\n      u2f.waitingForPort_.push(callback);\n    }\n  };\n\n  /**\n   * Handles response messages from the extension.\n   * @param {MessageEvent.<u2f.Response>} message\n   * @private\n   */\n  u2f.responseHandler_ = function(message) {\n    var response = message.data;\n    var reqId = response['requestId'];\n    if (!reqId || !u2f.callbackMap_[reqId]) {\n      console.error('Unknown or missing requestId in response.');\n      return;\n    }\n    var cb = u2f.callbackMap_[reqId];\n    delete u2f.callbackMap_[reqId];\n    cb(response['responseData']);\n  };\n\n  /**\n   * Dispatches an array of sign requests to available U2F tokens.\n   * If the JS API version supported by the extension is unknown, it first sends a\n   * message to the extension to find out the supported API version and then it sends\n   * the sign request.\n   * @param {string=} appId\n   * @param {string=} challenge\n   * @param {Array<u2f.RegisteredKey>} registeredKeys\n   * @param {function((u2f.Error|u2f.SignResponse))} callback\n   * @param {number=} opt_timeoutSeconds\n   */\n  u2f.sign = function(appId, challenge, registeredKeys, callback, opt_timeoutSeconds) {\n    if (js_api_version === undefined) {\n      // Send a message to get the extension to JS API version, then send the actual sign request.\n      u2f.getApiVersion(\n          function (response) {\n            js_api_version = response['js_api_version'] === undefined ? 0 : response['js_api_version'];\n            console.log(\"Extension JS API Version: \", js_api_version);\n            u2f.sendSignRequest(appId, challenge, registeredKeys, callback, opt_timeoutSeconds);\n          });\n    } else {\n      // We know the JS API version. Send the actual sign request in the supported API version.\n      u2f.sendSignRequest(appId, challenge, registeredKeys, callback, opt_timeoutSeconds);\n    }\n  };\n\n  /**\n   * Dispatches an array of sign requests to available U2F tokens.\n   * @param {string=} appId\n   * @param {string=} challenge\n   * @param {Array<u2f.RegisteredKey>} registeredKeys\n   * @param {function((u2f.Error|u2f.SignResponse))} callback\n   * @param {number=} opt_timeoutSeconds\n   */\n  u2f.sendSignRequest = function(appId, challenge, registeredKeys, callback, opt_timeoutSeconds) {\n    u2f.getPortSingleton_(function(port) {\n      var reqId = ++u2f.reqCounter_;\n      u2f.callbackMap_[reqId] = callback;\n      var timeoutSeconds = (typeof opt_timeoutSeconds !== 'undefined' ?\n          opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC);\n      var req = u2f.formatSignRequest_(appId, challenge, registeredKeys, timeoutSeconds, reqId);\n      port.postMessage(req);\n    });\n  };\n\n  /**\n   * Dispatches register requests to available U2F tokens. An array of sign\n   * requests identifies already registered tokens.\n   * If the JS API version supported by the extension is unknown, it first sends a\n   * message to the extension to find out the supported API version and then it sends\n   * the register request.\n   * @param {string=} appId\n   * @param {Array<u2f.RegisterRequest>} registerRequests\n   * @param {Array<u2f.RegisteredKey>} registeredKeys\n   * @param {function((u2f.Error|u2f.RegisterResponse))} callback\n   * @param {number=} opt_timeoutSeconds\n   */\n  u2f.register = function(appId, registerRequests, registeredKeys, callback, opt_timeoutSeconds) {\n    if (js_api_version === undefined) {\n      // Send a message to get the extension to JS API version, then send the actual register request.\n      u2f.getApiVersion(\n          function (response) {\n            js_api_version = response['js_api_version'] === undefined ? 0: response['js_api_version'];\n            console.log(\"Extension JS API Version: \", js_api_version);\n            u2f.sendRegisterRequest(appId, registerRequests, registeredKeys,\n                callback, opt_timeoutSeconds);\n          });\n    } else {\n      // We know the JS API version. Send the actual register request in the supported API version.\n      u2f.sendRegisterRequest(appId, registerRequests, registeredKeys,\n          callback, opt_timeoutSeconds);\n    }\n  };\n\n  /**\n   * Dispatches register requests to available U2F tokens. An array of sign\n   * requests identifies already registered tokens.\n   * @param {string=} appId\n   * @param {Array<u2f.RegisterRequest>} registerRequests\n   * @param {Array<u2f.RegisteredKey>} registeredKeys\n   * @param {function((u2f.Error|u2f.RegisterResponse))} callback\n   * @param {number=} opt_timeoutSeconds\n   */\n  u2f.sendRegisterRequest = function(appId, registerRequests, registeredKeys, callback, opt_timeoutSeconds) {\n    u2f.getPortSingleton_(function(port) {\n      var reqId = ++u2f.reqCounter_;\n      u2f.callbackMap_[reqId] = callback;\n      var timeoutSeconds = (typeof opt_timeoutSeconds !== 'undefined' ?\n          opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC);\n      var req = u2f.formatRegisterRequest_(\n          appId, registeredKeys, registerRequests, timeoutSeconds, reqId);\n      port.postMessage(req);\n    });\n  };\n\n\n  /**\n   * Dispatches a message to the extension to find out the supported\n   * JS API version.\n   * If the user is on a mobile phone and is thus using Google Authenticator instead\n   * of the Chrome extension, don't send the request and simply return 0.\n   * @param {function((u2f.Error|u2f.GetJsApiVersionResponse))} callback\n   * @param {number=} opt_timeoutSeconds\n   */\n  u2f.getApiVersion = function(callback, opt_timeoutSeconds) {\n   u2f.getPortSingleton_(function(port) {\n     // If we are using Android Google Authenticator or iOS client app,\n     // do not fire an intent to ask which JS API version to use.\n     if (port.getPortType) {\n       var apiVersion;\n       switch (port.getPortType()) {\n         case 'WrappedIosPort_':\n         case 'WrappedAuthenticatorPort_':\n           apiVersion = 1.1;\n           break;\n\n         default:\n           apiVersion = 0;\n           break;\n       }\n       callback({ 'js_api_version': apiVersion });\n       return;\n     }\n      var reqId = ++u2f.reqCounter_;\n      u2f.callbackMap_[reqId] = callback;\n      var req = {\n        type: u2f.MessageTypes.U2F_GET_API_VERSION_REQUEST,\n        timeoutSeconds: (typeof opt_timeoutSeconds !== 'undefined' ?\n            opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC),\n        requestId: reqId\n      };\n      port.postMessage(req);\n    });\n  };\n})();\n"]},"metadata":{},"sourceType":"script"}