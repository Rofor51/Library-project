{"ast":null,"code":"/* eslint-disable complexity, max-statements */\nvar http = require('./http');\n\nvar util = require('./util');\n\nvar oauthUtil = require('./oauthUtil');\n\nvar Q = require('q');\n\nvar sdkCrypto = require('./crypto');\n\nvar AuthSdkError = require('./errors/AuthSdkError');\n\nvar OAuthError = require('./errors/OAuthError');\n\nvar config = require('./config');\n\nvar cookies = require('./cookies');\n\nfunction decodeToken(token) {\n  var jwt = token.split('.');\n  var decodedToken;\n\n  try {\n    decodedToken = {\n      header: JSON.parse(util.base64UrlToString(jwt[0])),\n      payload: JSON.parse(util.base64UrlToString(jwt[1])),\n      signature: jwt[2]\n    };\n  } catch (e) {\n    throw new AuthSdkError('Malformed token');\n  }\n\n  return decodedToken;\n}\n\nfunction verifyIdToken(sdk, idToken, options) {\n  options = options || {};\n\n  if (!sdk.features.isTokenVerifySupported()) {\n    return Q.reject(new AuthSdkError('This browser doesn\\'t support crypto.subtle'));\n  }\n\n  function isExpired(jwtExp) {\n    var expirationTime;\n\n    if (options.expirationTime || options.expirationTime === 0) {\n      expirationTime = options.expirationTime;\n    } else {\n      expirationTime = Math.floor(Date.now() / 1000);\n    }\n\n    if (jwtExp && jwtExp > expirationTime) {\n      return true;\n    }\n  }\n\n  function hasAudience(jwtAudience) {\n    if (!options.audience) {\n      return true;\n    }\n\n    var audiences = Array.isArray(options.audience) ? options.audience : [options.audience];\n    var jwtAudiences = Array.isArray(jwtAudience) ? jwtAudience : [jwtAudience];\n    var ai = audiences.length;\n\n    while (ai--) {\n      var aud = audiences[ai];\n\n      if (jwtAudiences.indexOf(aud) !== -1) {\n        return true;\n      }\n    }\n  }\n\n  return oauthUtil.getWellKnown(sdk).then(function (res) {\n    return http.get(sdk, res['jwks_uri']);\n  }).then(function (res) {\n    var key = res.keys[0];\n    return sdkCrypto.verifyToken(idToken, key);\n  }).then(function (res) {\n    if (!res) {\n      return false;\n    }\n\n    var jwt = sdk.token.decode(idToken);\n\n    if (isExpired(jwt.payload.exp)) {\n      return false;\n    }\n\n    if (!hasAudience(jwt.payload.aud)) {\n      return false;\n    }\n\n    if (options.issuer && options.issuer !== jwt.payload.iss) {\n      return false;\n    }\n\n    return true;\n  });\n}\n\nfunction verifyToken(sdk, token, nonce, ignoreSignature) {\n  return new Q().then(function () {\n    if (!token || !token.idToken) {\n      throw new AuthSdkError('Only idTokens may be verified');\n    }\n\n    var jwt = decodeToken(token.idToken); // Standard claim validation\n\n    oauthUtil.validateClaims(sdk, jwt.payload, token.clientId, token.issuer, nonce); // If the browser doesn't support native crypto or we choose not \n    // to verify the signature, bail early\n\n    if (ignoreSignature || !sdk.features.isTokenVerifySupported()) {\n      return token;\n    }\n\n    return oauthUtil.getKey(sdk, token.issuer, jwt.header.kid).then(function (key) {\n      return sdkCrypto.verifyToken(token.idToken, key);\n    }).then(function (valid) {\n      if (!valid) {\n        throw new AuthSdkError('The token signature is not valid');\n      }\n\n      return token;\n    });\n  });\n}\n\nfunction refreshIdToken(sdk, options) {\n  options = options || {};\n  options.display = null;\n  options.prompt = 'none';\n  return getToken(sdk, options);\n}\n\nfunction addPostMessageListener(sdk, timeout, state) {\n  var deferred = Q.defer();\n\n  function responseHandler(e) {\n    if (!e.data || e.origin !== sdk.options.url || e.data && util.isString(state) && e.data.state !== state) {\n      return;\n    }\n\n    deferred.resolve(e.data);\n  }\n\n  oauthUtil.addListener(window, 'message', responseHandler);\n  return deferred.promise.timeout(timeout || 120000, new AuthSdkError('OAuth flow timed out')).fin(function () {\n    oauthUtil.removeListener(window, 'message', responseHandler);\n  });\n}\n\nfunction addFragmentListener(sdk, windowEl, timeout) {\n  var deferred = Q.defer();\n\n  function hashChangeHandler() {\n    /*\n      We are only able to access window.location.hash on a window\n      that has the same domain. A try/catch is necessary because\n      there's no other way to determine that the popup is in\n      another domain. When we try to access a window on another \n      domain, an error is thrown.\n    */\n    try {\n      if (windowEl && windowEl.location && windowEl.location.hash) {\n        deferred.resolve(oauthUtil.hashToObject(windowEl.location.hash));\n      } else if (windowEl && !windowEl.closed) {\n        setTimeout(hashChangeHandler, 500);\n      }\n    } catch (err) {\n      setTimeout(hashChangeHandler, 500);\n    }\n  }\n\n  hashChangeHandler();\n  return deferred.promise.timeout(timeout || 120000, new AuthSdkError('OAuth flow timed out'));\n}\n\nfunction handleOAuthResponse(sdk, oauthParams, res, urls) {\n  urls = urls || {};\n  var tokenTypes = oauthParams.responseType;\n  var scopes = util.clone(oauthParams.scopes);\n  var clientId = oauthParams.clientId || sdk.options.clientId;\n  return new Q().then(function () {\n    if (res['error'] || res['error_description']) {\n      throw new OAuthError(res['error'], res['error_description']);\n    }\n\n    if (res.state !== oauthParams.state) {\n      throw new AuthSdkError('OAuth flow response state doesn\\'t match request state');\n    }\n\n    var tokenDict = {};\n\n    if (res['access_token']) {\n      tokenDict['token'] = {\n        accessToken: res['access_token'],\n        expiresAt: Number(res['expires_in']) + Math.floor(Date.now() / 1000),\n        tokenType: res['token_type'],\n        scopes: scopes,\n        authorizeUrl: urls.authorizeUrl,\n        userinfoUrl: urls.userinfoUrl\n      };\n    }\n\n    if (res['code']) {\n      tokenDict['code'] = {\n        authorizationCode: res['code']\n      };\n    }\n\n    if (res['id_token']) {\n      var jwt = sdk.token.decode(res['id_token']);\n      var idToken = {\n        idToken: res['id_token'],\n        claims: jwt.payload,\n        expiresAt: jwt.payload.exp,\n        scopes: scopes,\n        authorizeUrl: urls.authorizeUrl,\n        issuer: urls.issuer,\n        clientId: clientId\n      };\n      return verifyToken(sdk, idToken, oauthParams.nonce, true).then(function () {\n        tokenDict['id_token'] = idToken;\n        return tokenDict;\n      });\n    }\n\n    return tokenDict;\n  }).then(function (tokenDict) {\n    if (!Array.isArray(tokenTypes)) {\n      return tokenDict[tokenTypes];\n    }\n\n    if (!tokenDict['token'] && !tokenDict['id_token']) {\n      throw new AuthSdkError('Unable to parse OAuth flow response');\n    } // Create token array in the order of the responseType array\n\n\n    return tokenTypes.map(function (item) {\n      return tokenDict[item];\n    });\n  });\n}\n\nfunction getDefaultOAuthParams(sdk, oauthOptions) {\n  oauthOptions = util.clone(oauthOptions) || {};\n\n  if (oauthOptions.scope) {\n    util.deprecate('The param \"scope\" is equivalent to \"scopes\". Use \"scopes\" instead.');\n    oauthOptions.scopes = oauthOptions.scope;\n    delete oauthOptions.scope;\n  }\n\n  var defaults = {\n    clientId: sdk.options.clientId,\n    redirectUri: sdk.options.redirectUri || window.location.href,\n    responseType: 'id_token',\n    responseMode: 'okta_post_message',\n    state: util.genRandomString(64),\n    nonce: util.genRandomString(64),\n    scopes: ['openid', 'email']\n  };\n  util.extend(defaults, oauthOptions);\n  return defaults;\n}\n\nfunction convertOAuthParamsToQueryParams(oauthParams) {\n  // Quick validation\n  if (!oauthParams.clientId) {\n    throw new AuthSdkError('A clientId must be specified in the OktaAuth constructor to get a token');\n  }\n\n  if (util.isString(oauthParams.responseType) && oauthParams.responseType.indexOf(' ') !== -1) {\n    throw new AuthSdkError('Multiple OAuth responseTypes must be defined as an array');\n  } // Convert our params to their actual OAuth equivalents\n\n\n  var oauthQueryParams = util.removeNils({\n    'client_id': oauthParams.clientId,\n    'redirect_uri': oauthParams.redirectUri,\n    'response_type': oauthParams.responseType,\n    'response_mode': oauthParams.responseMode,\n    'state': oauthParams.state,\n    'nonce': oauthParams.nonce,\n    'prompt': oauthParams.prompt,\n    'display': oauthParams.display,\n    'sessionToken': oauthParams.sessionToken,\n    'idp': oauthParams.idp,\n    'max_age': oauthParams.maxAge\n  });\n\n  if (Array.isArray(oauthQueryParams['response_type'])) {\n    oauthQueryParams['response_type'] = oauthQueryParams['response_type'].join(' ');\n  }\n\n  if (oauthParams.responseType.indexOf('id_token') !== -1 && oauthParams.scopes.indexOf('openid') === -1) {\n    throw new AuthSdkError('openid scope must be specified in the scopes argument when requesting an id_token');\n  } else {\n    oauthQueryParams.scope = oauthParams.scopes.join(' ');\n  }\n\n  return oauthQueryParams;\n}\n\nfunction buildAuthorizeParams(oauthParams) {\n  var oauthQueryParams = convertOAuthParamsToQueryParams(oauthParams);\n  return util.toQueryParams(oauthQueryParams);\n}\n/*\n * Retrieve an idToken from an Okta or a third party idp\n * \n * Two main flows:\n *\n *  1) Exchange a sessionToken for a token\n * \n *    Required:\n *      clientId: passed via the OktaAuth constructor or into getToken\n *      sessionToken: 'yourtoken'\n *\n *    Optional:\n *      redirectUri: defaults to window.location.href\n *      scopes: defaults to ['openid', 'email']\n *\n *    Forced:\n *      prompt: 'none'\n *      responseMode: 'okta_post_message'\n *      display: undefined\n *\n *  2) Get a token from an idp\n *\n *    Required:\n *      clientId: passed via the OktaAuth constructor or into getToken\n *\n *    Optional:\n *      redirectUri: defaults to window.location.href\n *      scopes: defaults to ['openid', 'email']\n *      idp: defaults to Okta as an idp\n *      prompt: no default. Pass 'none' to throw an error if user is not signed in\n *\n *    Forced:\n *      display: 'popup'\n *\n *  Only common optional params shown. Any OAuth parameters not explicitly forced are available to override\n *\n * @param {Object} oauthOptions\n * @param {String} [oauthOptions.clientId] ID of this client\n * @param {String} [oauthOptions.redirectUri] URI that the iframe or popup will go to once authenticated\n * @param {String[]} [oauthOptions.scopes] OAuth 2.0 scopes to request (openid must be specified)\n * @param {String} [oauthOptions.idp] ID of an external IdP to use for user authentication\n * @param {String} [oauthOptions.sessionToken] Bootstrap Session Token returned by the Okta Authentication API\n * @param {String} [oauthOptions.prompt] Determines whether the Okta login will be displayed on failure.\n *                                       Use 'none' to prevent this behavior\n *\n * @param {Object} options\n * @param {Integer} [options.timeout] Time in ms before the flow is automatically terminated. Defaults to 120000\n * @param {String} [options.popupTitle] Title dispayed in the popup.\n *                                      Defaults to 'External Identity Provider User Authentication'\n */\n\n\nfunction getToken(sdk, oauthOptions, options) {\n  oauthOptions = oauthOptions || {};\n  options = options || {}; // Default OAuth query params\n\n  var oauthParams = getDefaultOAuthParams(sdk, oauthOptions); // Start overriding any options that don't make sense\n\n  var sessionTokenOverrides = {\n    prompt: 'none',\n    responseMode: 'okta_post_message',\n    display: null\n  };\n  var idpOverrides = {\n    display: 'popup'\n  };\n\n  if (oauthOptions.sessionToken) {\n    util.extend(oauthParams, sessionTokenOverrides);\n  } else if (oauthOptions.idp) {\n    util.extend(oauthParams, idpOverrides);\n  } // Use the query params to build the authorize url\n\n\n  var requestUrl, urls;\n\n  try {\n    // Get authorizeUrl and issuer\n    urls = oauthUtil.getOAuthUrls(sdk, oauthParams, options);\n    requestUrl = urls.authorizeUrl + buildAuthorizeParams(oauthParams);\n  } catch (e) {\n    return Q.reject(e);\n  } // Determine the flow type\n\n\n  var flowType;\n\n  if (oauthParams.sessionToken || oauthParams.display === null) {\n    flowType = 'IFRAME';\n  } else if (oauthParams.display === 'popup') {\n    flowType = 'POPUP';\n  } else {\n    flowType = 'IMPLICIT';\n  }\n\n  function getOrigin(url) {\n    var originRegex = /^(https?\\:\\/\\/)?([^:\\/?#]*(?:\\:[0-9]+)?)/;\n    return originRegex.exec(url)[0];\n  } // Execute the flow type\n\n\n  switch (flowType) {\n    case 'IFRAME':\n      var iframePromise = addPostMessageListener(sdk, options.timeout, oauthParams.state);\n      var iframeEl = oauthUtil.loadFrame(requestUrl);\n      return iframePromise.then(function (res) {\n        return handleOAuthResponse(sdk, oauthParams, res, urls);\n      }).fin(function () {\n        if (document.body.contains(iframeEl)) {\n          iframeEl.parentElement.removeChild(iframeEl);\n        }\n      });\n\n    case 'POPUP':\n      // eslint-disable-line no-case-declarations\n      var popupPromise; // Add listener on postMessage before window creation, so\n      // postMessage isn't triggered before we're listening\n\n      if (oauthParams.responseMode === 'okta_post_message') {\n        if (!sdk.features.isPopupPostMessageSupported()) {\n          return Q.reject(new AuthSdkError('This browser doesn\\'t have full postMessage support'));\n        }\n\n        popupPromise = addPostMessageListener(sdk, options.timeout, oauthParams.state);\n      } // Create the window\n\n\n      var windowOptions = {\n        popupTitle: options.popupTitle\n      };\n      var windowEl = oauthUtil.loadPopup(requestUrl, windowOptions); // Poll until we get a valid hash fragment\n\n      if (oauthParams.responseMode === 'fragment') {\n        var windowOrigin = getOrigin(sdk.idToken.authorize._getLocationHref());\n        var redirectUriOrigin = getOrigin(oauthParams.redirectUri);\n\n        if (windowOrigin !== redirectUriOrigin) {\n          return Q.reject(new AuthSdkError('Using fragment, the redirectUri origin (' + redirectUriOrigin + ') must match the origin of this page (' + windowOrigin + ')'));\n        }\n\n        popupPromise = addFragmentListener(sdk, windowEl, options.timeout);\n      } // Both postMessage and fragment require a poll to see if the popup closed\n\n\n      var popupDeferred = Q.defer();\n\n      function hasClosed(win) {\n        // eslint-disable-line no-inner-declarations\n        if (win.closed) {\n          popupDeferred.reject(new AuthSdkError('Unable to parse OAuth flow response'));\n        }\n      }\n\n      var closePoller = setInterval(function () {\n        hasClosed(windowEl);\n      }, 500); // Proxy the promise results into the deferred\n\n      popupPromise.then(function (res) {\n        popupDeferred.resolve(res);\n      }).fail(function (err) {\n        popupDeferred.reject(err);\n      });\n      return popupDeferred.promise.then(function (res) {\n        return handleOAuthResponse(sdk, oauthParams, res, urls);\n      }).fin(function () {\n        if (!windowEl.closed) {\n          clearInterval(closePoller);\n          windowEl.close();\n        }\n      });\n\n    default:\n      return Q.reject(new AuthSdkError('The full page redirect flow is not supported'));\n  }\n}\n\nfunction getWithoutPrompt(sdk, oauthOptions, options) {\n  var oauthParams = util.clone(oauthOptions) || {};\n  util.extend(oauthParams, {\n    prompt: 'none',\n    responseMode: 'okta_post_message',\n    display: null\n  });\n  return getToken(sdk, oauthParams, options);\n}\n\nfunction getWithPopup(sdk, oauthOptions, options) {\n  var oauthParams = util.clone(oauthOptions) || {};\n  util.extend(oauthParams, {\n    display: 'popup'\n  });\n  return getToken(sdk, oauthParams, options);\n}\n\nfunction getWithRedirect(sdk, oauthOptions, options) {\n  oauthOptions = util.clone(oauthOptions) || {};\n  var oauthParams = getDefaultOAuthParams(sdk, oauthOptions); // If the user didn't specify a responseMode\n\n  if (!oauthOptions.responseMode) {\n    // And it's only an auth code request (responseType could be an array)\n    var respType = oauthParams.responseType;\n\n    if (respType.indexOf('code') !== -1 && (util.isString(respType) || Array.isArray(respType) && respType.length === 1)) {\n      // Default the responseMode to query\n      util.extend(oauthParams, {\n        responseMode: 'query'\n      }); // Otherwise, default to fragment\n    } else {\n      util.extend(oauthParams, {\n        responseMode: 'fragment'\n      });\n    }\n  }\n\n  var urls = oauthUtil.getOAuthUrls(sdk, oauthParams, options);\n  var requestUrl = urls.authorizeUrl + buildAuthorizeParams(oauthParams); // Set session cookie to store the oauthParams\n\n  cookies.setCookie(config.REDIRECT_OAUTH_PARAMS_COOKIE_NAME, JSON.stringify({\n    responseType: oauthParams.responseType,\n    state: oauthParams.state,\n    nonce: oauthParams.nonce,\n    scopes: oauthParams.scopes,\n    urls: urls\n  })); // Set nonce cookie for servers to validate nonce in id_token\n\n  cookies.setCookie(config.REDIRECT_NONCE_COOKIE_NAME, oauthParams.nonce); // Set state cookie for servers to validate state\n\n  cookies.setCookie(config.REDIRECT_STATE_COOKIE_NAME, oauthParams.state);\n\n  sdk.token.getWithRedirect._setLocation(requestUrl);\n}\n\nfunction refreshToken(sdk, token) {\n  if (!oauthUtil.isToken(token)) {\n    return Q.reject(new AuthSdkError('Refresh must be passed a token with ' + 'an array of scopes and an accessToken or idToken'));\n  }\n\n  var responseType;\n\n  if (token.accessToken) {\n    responseType = 'token';\n  } else {\n    responseType = 'id_token';\n  }\n\n  return sdk.token.getWithoutPrompt({\n    responseType: responseType,\n    scopes: token.scopes\n  }, {\n    authorizeUrl: token.authorizeUrl,\n    userinfoUrl: token.userinfoUrl,\n    issuer: token.issuer\n  });\n}\n\nfunction removeHash(sdk) {\n  var nativeHistory = sdk.token.parseFromUrl._getHistory();\n\n  var nativeDoc = sdk.token.parseFromUrl._getDocument();\n\n  var nativeLoc = sdk.token.parseFromUrl._getLocation();\n\n  if (nativeHistory && nativeHistory.replaceState) {\n    nativeHistory.replaceState(null, nativeDoc.title, nativeLoc.pathname + nativeLoc.search);\n  } else {\n    nativeLoc.hash = '';\n  }\n}\n\nfunction parseFromUrl(sdk, url) {\n  var nativeLoc = sdk.token.parseFromUrl._getLocation();\n\n  var hash = nativeLoc.hash;\n\n  if (url) {\n    hash = url.substring(url.indexOf('#'));\n  }\n\n  var oauthParamsCookie = cookies.getCookie(config.REDIRECT_OAUTH_PARAMS_COOKIE_NAME);\n\n  if (!hash || !oauthParamsCookie) {\n    return Q.reject(new AuthSdkError('Unable to parse a token from the url'));\n  }\n\n  try {\n    var oauthParams = JSON.parse(oauthParamsCookie);\n    var urls = oauthParams.urls;\n    delete oauthParams.urls;\n    cookies.deleteCookie(config.REDIRECT_OAUTH_PARAMS_COOKIE_NAME);\n  } catch (e) {\n    return Q.reject(new AuthSdkError('Unable to parse the ' + config.REDIRECT_OAUTH_PARAMS_COOKIE_NAME + ' cookie: ' + e.message));\n  }\n\n  return Q.resolve(oauthUtil.hashToObject(hash)).then(function (res) {\n    if (!url) {\n      // Remove the hash from the url\n      removeHash(sdk);\n    }\n\n    return handleOAuthResponse(sdk, oauthParams, res, urls);\n  });\n}\n\nfunction getUserInfo(sdk, accessTokenObject) {\n  if (!accessTokenObject || !oauthUtil.isToken(accessTokenObject) && !accessTokenObject.accessToken && !accessTokenObject.userinfoUrl) {\n    return Q.reject(new AuthSdkError('getUserInfo requires an access token object'));\n  }\n\n  return http.httpRequest(sdk, {\n    url: accessTokenObject.userinfoUrl,\n    method: 'GET',\n    accessToken: accessTokenObject.accessToken\n  }).fail(function (err) {\n    if (err.xhr && (err.xhr.status === 401 || err.xhr.status === 403)) {\n      var authenticateHeader = err.xhr.getResponseHeader('WWW-Authenticate');\n\n      if (authenticateHeader) {\n        var errorMatches = authenticateHeader.match(/error=\"(.*?)\"/) || [];\n        var errorDescriptionMatches = authenticateHeader.match(/error_description=\"(.*?)\"/) || [];\n        var error = errorMatches[1];\n        var errorDescription = errorDescriptionMatches[1];\n\n        if (error && errorDescription) {\n          err = new OAuthError(error, errorDescription);\n        }\n      }\n    }\n\n    throw err;\n  });\n}\n\nmodule.exports = {\n  getToken: getToken,\n  getWithoutPrompt: getWithoutPrompt,\n  getWithPopup: getWithPopup,\n  getWithRedirect: getWithRedirect,\n  parseFromUrl: parseFromUrl,\n  refreshIdToken: refreshIdToken,\n  decodeToken: decodeToken,\n  verifyIdToken: verifyIdToken,\n  refreshToken: refreshToken,\n  getUserInfo: getUserInfo,\n  verifyToken: verifyToken\n};","map":{"version":3,"sources":["C:/Users/robin/Desktop/Library/Library-React/my-app/node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/lib/token.js"],"names":["http","require","util","oauthUtil","Q","sdkCrypto","AuthSdkError","OAuthError","config","cookies","decodeToken","token","jwt","split","decodedToken","header","JSON","parse","base64UrlToString","payload","signature","e","verifyIdToken","sdk","idToken","options","features","isTokenVerifySupported","reject","isExpired","jwtExp","expirationTime","Math","floor","Date","now","hasAudience","jwtAudience","audience","audiences","Array","isArray","jwtAudiences","ai","length","aud","indexOf","getWellKnown","then","res","get","key","keys","verifyToken","decode","exp","issuer","iss","nonce","ignoreSignature","validateClaims","clientId","getKey","kid","valid","refreshIdToken","display","prompt","getToken","addPostMessageListener","timeout","state","deferred","defer","responseHandler","data","origin","url","isString","resolve","addListener","window","promise","fin","removeListener","addFragmentListener","windowEl","hashChangeHandler","location","hash","hashToObject","closed","setTimeout","err","handleOAuthResponse","oauthParams","urls","tokenTypes","responseType","scopes","clone","tokenDict","accessToken","expiresAt","Number","tokenType","authorizeUrl","userinfoUrl","authorizationCode","claims","map","item","getDefaultOAuthParams","oauthOptions","scope","deprecate","defaults","redirectUri","href","responseMode","genRandomString","extend","convertOAuthParamsToQueryParams","oauthQueryParams","removeNils","sessionToken","idp","maxAge","join","buildAuthorizeParams","toQueryParams","sessionTokenOverrides","idpOverrides","requestUrl","getOAuthUrls","flowType","getOrigin","originRegex","exec","iframePromise","iframeEl","loadFrame","document","body","contains","parentElement","removeChild","popupPromise","isPopupPostMessageSupported","windowOptions","popupTitle","loadPopup","windowOrigin","authorize","_getLocationHref","redirectUriOrigin","popupDeferred","hasClosed","win","closePoller","setInterval","fail","clearInterval","close","getWithoutPrompt","getWithPopup","getWithRedirect","respType","setCookie","REDIRECT_OAUTH_PARAMS_COOKIE_NAME","stringify","REDIRECT_NONCE_COOKIE_NAME","REDIRECT_STATE_COOKIE_NAME","_setLocation","refreshToken","isToken","removeHash","nativeHistory","parseFromUrl","_getHistory","nativeDoc","_getDocument","nativeLoc","_getLocation","replaceState","title","pathname","search","substring","oauthParamsCookie","getCookie","deleteCookie","message","getUserInfo","accessTokenObject","httpRequest","method","xhr","status","authenticateHeader","getResponseHeader","errorMatches","match","errorDescriptionMatches","error","errorDescription","module","exports"],"mappings":"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","sourcesContent":["/* eslint-disable complexity, max-statements */\nvar http          = require('./http');\nvar util          = require('./util');\nvar oauthUtil     = require('./oauthUtil');\nvar Q             = require('q');\nvar sdkCrypto     = require('./crypto');\nvar AuthSdkError  = require('./errors/AuthSdkError');\nvar OAuthError    = require('./errors/OAuthError');\nvar config        = require('./config');\nvar cookies       = require('./cookies');\n\nfunction decodeToken(token) {\n  var jwt = token.split('.');\n  var decodedToken;\n\n  try {\n    decodedToken = {\n      header: JSON.parse(util.base64UrlToString(jwt[0])),\n      payload: JSON.parse(util.base64UrlToString(jwt[1])),\n      signature: jwt[2]\n    };\n  } catch(e) {\n    throw new AuthSdkError('Malformed token');\n  }\n\n  return decodedToken;\n}\n\nfunction verifyIdToken(sdk, idToken, options) {\n  options = options || {};\n\n  if (!sdk.features.isTokenVerifySupported()) {\n    return Q.reject(new AuthSdkError('This browser doesn\\'t support crypto.subtle'));\n  }\n\n  function isExpired(jwtExp) {\n    var expirationTime;\n    if (options.expirationTime || options.expirationTime === 0) {\n      expirationTime = options.expirationTime;\n    } else {\n      expirationTime = Math.floor(Date.now()/1000);\n    }\n    if (jwtExp &&\n        jwtExp > expirationTime) {\n      return true;\n    }\n  }\n\n  function hasAudience(jwtAudience) {\n    if (!options.audience) {\n      return true;\n    }\n    var audiences = Array.isArray(options.audience) ? options.audience : [options.audience];\n    var jwtAudiences = Array.isArray(jwtAudience) ? jwtAudience : [jwtAudience];\n    var ai = audiences.length;\n    while (ai--) {\n      var aud = audiences[ai];\n      if (jwtAudiences.indexOf(aud) !== -1) {\n        return true;\n      }\n    }\n  }\n\n  return oauthUtil.getWellKnown(sdk)\n    .then(function(res) {\n      return http.get(sdk, res['jwks_uri']);\n    })\n    .then(function(res) {\n      var key = res.keys[0];\n      return sdkCrypto.verifyToken(idToken, key);\n    })\n    .then(function(res) {\n      if (!res) {\n        return false;\n      }\n      var jwt = sdk.token.decode(idToken);\n\n      if (isExpired(jwt.payload.exp)) {\n        return false;\n      }\n\n      if (!hasAudience(jwt.payload.aud)) {\n        return false;\n      }\n\n      if (options.issuer &&\n          options.issuer !== jwt.payload.iss) {\n        return false;\n      }\n\n      return true;\n    });\n}\n\nfunction verifyToken(sdk, token, nonce, ignoreSignature) {\n  return new Q()\n  .then(function() {\n    if (!token || !token.idToken) {\n      throw new AuthSdkError('Only idTokens may be verified');\n    }\n\n    var jwt = decodeToken(token.idToken);\n\n    // Standard claim validation\n    oauthUtil.validateClaims(sdk, jwt.payload, token.clientId, token.issuer, nonce);\n\n    // If the browser doesn't support native crypto or we choose not \n    // to verify the signature, bail early\n    if (ignoreSignature || !sdk.features.isTokenVerifySupported()) {\n      return token;\n    }\n\n    return oauthUtil.getKey(sdk, token.issuer, jwt.header.kid)\n    .then(function(key) {\n      return sdkCrypto.verifyToken(token.idToken, key);\n    })\n    .then(function(valid) {\n      if (!valid) {\n        throw new AuthSdkError('The token signature is not valid');\n      }\n      return token;\n    });\n  });\n}\n\nfunction refreshIdToken(sdk, options) {\n  options = options || {};\n  options.display = null;\n  options.prompt = 'none';\n  return getToken(sdk, options);\n}\n\nfunction addPostMessageListener(sdk, timeout, state) {\n  var deferred = Q.defer();\n\n  function responseHandler(e) {\n    if (!e.data ||\n        e.origin !== sdk.options.url ||\n        (e.data && util.isString(state) && e.data.state !== state)) {\n      return;\n    }\n    deferred.resolve(e.data);\n  }\n\n  oauthUtil.addListener(window, 'message', responseHandler);\n\n  return deferred.promise.timeout(timeout || 120000, new AuthSdkError('OAuth flow timed out'))\n    .fin(function() {\n      oauthUtil.removeListener(window, 'message', responseHandler);\n    });\n}\n\nfunction addFragmentListener(sdk, windowEl, timeout) {\n  var deferred = Q.defer();\n\n  function hashChangeHandler() {\n    /*\n      We are only able to access window.location.hash on a window\n      that has the same domain. A try/catch is necessary because\n      there's no other way to determine that the popup is in\n      another domain. When we try to access a window on another \n      domain, an error is thrown.\n    */\n    try {\n      if (windowEl &&\n          windowEl.location &&\n          windowEl.location.hash) {\n        deferred.resolve(oauthUtil.hashToObject(windowEl.location.hash));\n      } else if (windowEl && !windowEl.closed) {\n        setTimeout(hashChangeHandler, 500);\n      }\n    } catch (err) {\n      setTimeout(hashChangeHandler, 500);\n    }\n  }\n\n  hashChangeHandler();\n\n  return deferred.promise.timeout(timeout || 120000, new AuthSdkError('OAuth flow timed out'));\n}\n\nfunction handleOAuthResponse(sdk, oauthParams, res, urls) {\n  urls = urls || {};\n\n  var tokenTypes = oauthParams.responseType;\n  var scopes = util.clone(oauthParams.scopes);\n  var clientId = oauthParams.clientId || sdk.options.clientId;\n\n  return new Q()\n  .then(function() {\n    if (res['error'] || res['error_description']) {\n      throw new OAuthError(res['error'], res['error_description']);\n    }\n\n    if (res.state !== oauthParams.state) {\n      throw new AuthSdkError('OAuth flow response state doesn\\'t match request state');\n    }\n\n    var tokenDict = {};\n    \n    if (res['access_token']) {\n      tokenDict['token'] = {\n        accessToken: res['access_token'],\n        expiresAt: Number(res['expires_in']) + Math.floor(Date.now()/1000),\n        tokenType: res['token_type'],\n        scopes: scopes,\n        authorizeUrl: urls.authorizeUrl,\n        userinfoUrl: urls.userinfoUrl\n      };\n    }\n\n    if (res['code']) {\n      tokenDict['code'] = {\n        authorizationCode: res['code']\n      };\n    }\n\n    if (res['id_token']) {\n      var jwt = sdk.token.decode(res['id_token']);\n\n      var idToken = {\n        idToken: res['id_token'],\n        claims: jwt.payload,\n        expiresAt: jwt.payload.exp,\n        scopes: scopes,\n        authorizeUrl: urls.authorizeUrl,\n        issuer: urls.issuer,\n        clientId: clientId\n      };\n\n      return verifyToken(sdk, idToken, oauthParams.nonce, true)\n      .then(function() {\n        tokenDict['id_token'] = idToken;\n        return tokenDict;\n      });\n    }\n\n    return tokenDict;\n  })\n  .then(function(tokenDict) {\n    if (!Array.isArray(tokenTypes)) {\n      return tokenDict[tokenTypes];\n    }\n\n    if (!tokenDict['token'] && !tokenDict['id_token']) {\n      throw new AuthSdkError('Unable to parse OAuth flow response');\n    }\n\n    // Create token array in the order of the responseType array\n    return tokenTypes.map(function(item) {\n      return tokenDict[item];\n    });\n  });\n}\n\nfunction getDefaultOAuthParams(sdk, oauthOptions) {\n  oauthOptions = util.clone(oauthOptions) || {};\n\n  if (oauthOptions.scope) {\n    util.deprecate('The param \"scope\" is equivalent to \"scopes\". Use \"scopes\" instead.');\n    oauthOptions.scopes = oauthOptions.scope;\n    delete oauthOptions.scope;\n  }\n\n  var defaults = {\n    clientId: sdk.options.clientId,\n    redirectUri: sdk.options.redirectUri || window.location.href,\n    responseType: 'id_token',\n    responseMode: 'okta_post_message',\n    state: util.genRandomString(64),\n    nonce: util.genRandomString(64),\n    scopes: ['openid', 'email']\n  };\n  util.extend(defaults, oauthOptions);\n  return defaults;\n}\n\nfunction convertOAuthParamsToQueryParams(oauthParams) {\n  // Quick validation\n  if (!oauthParams.clientId) {\n    throw new AuthSdkError('A clientId must be specified in the OktaAuth constructor to get a token');\n  }\n\n  if (util.isString(oauthParams.responseType) && oauthParams.responseType.indexOf(' ') !== -1) {\n    throw new AuthSdkError('Multiple OAuth responseTypes must be defined as an array');\n  }\n\n  // Convert our params to their actual OAuth equivalents\n  var oauthQueryParams = util.removeNils({\n    'client_id': oauthParams.clientId,\n    'redirect_uri': oauthParams.redirectUri,\n    'response_type': oauthParams.responseType,\n    'response_mode': oauthParams.responseMode,\n    'state': oauthParams.state,\n    'nonce': oauthParams.nonce,\n    'prompt': oauthParams.prompt,\n    'display': oauthParams.display,\n    'sessionToken': oauthParams.sessionToken,\n    'idp': oauthParams.idp,\n    'max_age': oauthParams.maxAge\n  });\n\n  if (Array.isArray(oauthQueryParams['response_type'])) {\n    oauthQueryParams['response_type'] = oauthQueryParams['response_type'].join(' ');\n  }\n\n  if (oauthParams.responseType.indexOf('id_token') !== -1 &&\n      oauthParams.scopes.indexOf('openid') === -1) {\n    throw new AuthSdkError('openid scope must be specified in the scopes argument when requesting an id_token');\n  } else {\n    oauthQueryParams.scope = oauthParams.scopes.join(' ');\n  }\n\n  return oauthQueryParams;\n}\n\nfunction buildAuthorizeParams(oauthParams) {\n  var oauthQueryParams = convertOAuthParamsToQueryParams(oauthParams);\n  return util.toQueryParams(oauthQueryParams);\n}\n\n/*\n * Retrieve an idToken from an Okta or a third party idp\n * \n * Two main flows:\n *\n *  1) Exchange a sessionToken for a token\n * \n *    Required:\n *      clientId: passed via the OktaAuth constructor or into getToken\n *      sessionToken: 'yourtoken'\n *\n *    Optional:\n *      redirectUri: defaults to window.location.href\n *      scopes: defaults to ['openid', 'email']\n *\n *    Forced:\n *      prompt: 'none'\n *      responseMode: 'okta_post_message'\n *      display: undefined\n *\n *  2) Get a token from an idp\n *\n *    Required:\n *      clientId: passed via the OktaAuth constructor or into getToken\n *\n *    Optional:\n *      redirectUri: defaults to window.location.href\n *      scopes: defaults to ['openid', 'email']\n *      idp: defaults to Okta as an idp\n *      prompt: no default. Pass 'none' to throw an error if user is not signed in\n *\n *    Forced:\n *      display: 'popup'\n *\n *  Only common optional params shown. Any OAuth parameters not explicitly forced are available to override\n *\n * @param {Object} oauthOptions\n * @param {String} [oauthOptions.clientId] ID of this client\n * @param {String} [oauthOptions.redirectUri] URI that the iframe or popup will go to once authenticated\n * @param {String[]} [oauthOptions.scopes] OAuth 2.0 scopes to request (openid must be specified)\n * @param {String} [oauthOptions.idp] ID of an external IdP to use for user authentication\n * @param {String} [oauthOptions.sessionToken] Bootstrap Session Token returned by the Okta Authentication API\n * @param {String} [oauthOptions.prompt] Determines whether the Okta login will be displayed on failure.\n *                                       Use 'none' to prevent this behavior\n *\n * @param {Object} options\n * @param {Integer} [options.timeout] Time in ms before the flow is automatically terminated. Defaults to 120000\n * @param {String} [options.popupTitle] Title dispayed in the popup.\n *                                      Defaults to 'External Identity Provider User Authentication'\n */\nfunction getToken(sdk, oauthOptions, options) {\n  oauthOptions = oauthOptions || {};\n  options = options || {};\n\n  // Default OAuth query params\n  var oauthParams = getDefaultOAuthParams(sdk, oauthOptions);\n\n  // Start overriding any options that don't make sense\n  var sessionTokenOverrides = {\n    prompt: 'none',\n    responseMode: 'okta_post_message',\n    display: null\n  };\n\n  var idpOverrides = {\n    display: 'popup'\n  };\n\n  if (oauthOptions.sessionToken) {\n    util.extend(oauthParams, sessionTokenOverrides);\n  } else if (oauthOptions.idp) {\n    util.extend(oauthParams, idpOverrides);\n  }\n\n  // Use the query params to build the authorize url\n  var requestUrl,\n      urls;\n  try {\n    // Get authorizeUrl and issuer\n    urls = oauthUtil.getOAuthUrls(sdk, oauthParams, options);\n    requestUrl = urls.authorizeUrl + buildAuthorizeParams(oauthParams);\n  } catch (e) {\n    return Q.reject(e);\n  }\n\n  // Determine the flow type\n  var flowType;\n  if (oauthParams.sessionToken || oauthParams.display === null) {\n    flowType = 'IFRAME';\n  } else if (oauthParams.display === 'popup') {\n    flowType = 'POPUP';\n  } else {\n    flowType = 'IMPLICIT';\n  }\n\n  function getOrigin(url) {\n    var originRegex = /^(https?\\:\\/\\/)?([^:\\/?#]*(?:\\:[0-9]+)?)/;\n    return originRegex.exec(url)[0];\n  }\n\n  // Execute the flow type\n  switch (flowType) {\n    case 'IFRAME':\n      var iframePromise = addPostMessageListener(sdk, options.timeout, oauthParams.state);\n      var iframeEl = oauthUtil.loadFrame(requestUrl);\n      return iframePromise\n        .then(function(res) {\n          return handleOAuthResponse(sdk, oauthParams, res, urls);\n        })\n        .fin(function() {\n          if (document.body.contains(iframeEl)) {\n            iframeEl.parentElement.removeChild(iframeEl);\n          }\n        });\n\n    case 'POPUP': // eslint-disable-line no-case-declarations\n      var popupPromise;\n\n      // Add listener on postMessage before window creation, so\n      // postMessage isn't triggered before we're listening\n      if (oauthParams.responseMode === 'okta_post_message') {\n        if (!sdk.features.isPopupPostMessageSupported()) {\n          return Q.reject(new AuthSdkError('This browser doesn\\'t have full postMessage support'));\n        }\n        popupPromise = addPostMessageListener(sdk, options.timeout, oauthParams.state);\n      }\n\n      // Create the window\n      var windowOptions = {\n        popupTitle: options.popupTitle\n      };\n      var windowEl = oauthUtil.loadPopup(requestUrl, windowOptions);\n\n      // Poll until we get a valid hash fragment\n      if (oauthParams.responseMode === 'fragment') {\n        var windowOrigin = getOrigin(sdk.idToken.authorize._getLocationHref());\n        var redirectUriOrigin = getOrigin(oauthParams.redirectUri);\n        if (windowOrigin !== redirectUriOrigin) {\n          return Q.reject(new AuthSdkError('Using fragment, the redirectUri origin (' + redirectUriOrigin +\n            ') must match the origin of this page (' + windowOrigin + ')'));\n        }\n        popupPromise = addFragmentListener(sdk, windowEl, options.timeout);\n      }\n\n      // Both postMessage and fragment require a poll to see if the popup closed\n      var popupDeferred = Q.defer();\n      function hasClosed(win) { // eslint-disable-line no-inner-declarations\n        if (win.closed) {\n          popupDeferred.reject(new AuthSdkError('Unable to parse OAuth flow response'));\n        }\n      }\n      var closePoller = setInterval(function() {\n        hasClosed(windowEl);\n      }, 500);\n\n      // Proxy the promise results into the deferred\n      popupPromise\n      .then(function(res) {\n        popupDeferred.resolve(res);\n      })\n      .fail(function(err) {\n        popupDeferred.reject(err);\n      });\n\n      return popupDeferred.promise\n        .then(function(res) {\n          return handleOAuthResponse(sdk, oauthParams, res, urls);\n        })\n        .fin(function() {\n          if (!windowEl.closed) {\n            clearInterval(closePoller);\n            windowEl.close();\n          }\n        });\n\n    default:\n      return Q.reject(new AuthSdkError('The full page redirect flow is not supported'));\n  }\n}\n\nfunction getWithoutPrompt(sdk, oauthOptions, options) {\n  var oauthParams = util.clone(oauthOptions) || {};\n  util.extend(oauthParams, {\n    prompt: 'none',\n    responseMode: 'okta_post_message',\n    display: null\n  });\n  return getToken(sdk, oauthParams, options);\n}\n\nfunction getWithPopup(sdk, oauthOptions, options) {\n  var oauthParams = util.clone(oauthOptions) || {};\n  util.extend(oauthParams, {\n    display: 'popup'\n  });\n  return getToken(sdk, oauthParams, options);\n}\n\nfunction getWithRedirect(sdk, oauthOptions, options) {\n  oauthOptions = util.clone(oauthOptions) || {};\n  var oauthParams = getDefaultOAuthParams(sdk, oauthOptions);\n  // If the user didn't specify a responseMode\n  if (!oauthOptions.responseMode) {\n    // And it's only an auth code request (responseType could be an array)\n    var respType = oauthParams.responseType;\n    if (respType.indexOf('code') !== -1 &&\n        (util.isString(respType) || (Array.isArray(respType) && respType.length === 1))) {\n        // Default the responseMode to query\n        util.extend(oauthParams, {\n          responseMode: 'query'\n        });\n    // Otherwise, default to fragment\n    } else {\n      util.extend(oauthParams, {\n        responseMode: 'fragment'\n      });\n    }\n  }\n  \n  var urls = oauthUtil.getOAuthUrls(sdk, oauthParams, options);\n  var requestUrl = urls.authorizeUrl + buildAuthorizeParams(oauthParams);\n\n  // Set session cookie to store the oauthParams\n  cookies.setCookie(config.REDIRECT_OAUTH_PARAMS_COOKIE_NAME, JSON.stringify({\n    responseType: oauthParams.responseType,\n    state: oauthParams.state,\n    nonce: oauthParams.nonce,\n    scopes: oauthParams.scopes,\n    urls: urls\n  }));\n\n  // Set nonce cookie for servers to validate nonce in id_token\n  cookies.setCookie(config.REDIRECT_NONCE_COOKIE_NAME, oauthParams.nonce);\n\n  // Set state cookie for servers to validate state\n  cookies.setCookie(config.REDIRECT_STATE_COOKIE_NAME, oauthParams.state);\n\n  sdk.token.getWithRedirect._setLocation(requestUrl);\n}\n\nfunction refreshToken(sdk, token) {\n  if (!oauthUtil.isToken(token)) {\n    return Q.reject(new AuthSdkError('Refresh must be passed a token with ' +\n      'an array of scopes and an accessToken or idToken'));\n  }\n\n  var responseType;\n  if (token.accessToken) {\n    responseType = 'token';\n  } else {\n    responseType = 'id_token';\n  }\n  return sdk.token.getWithoutPrompt({\n    responseType: responseType,\n    scopes: token.scopes\n  }, {\n    authorizeUrl: token.authorizeUrl,\n    userinfoUrl: token.userinfoUrl,\n    issuer: token.issuer\n  });\n}\n\nfunction removeHash(sdk) {\n  var nativeHistory = sdk.token.parseFromUrl._getHistory();\n  var nativeDoc = sdk.token.parseFromUrl._getDocument();\n  var nativeLoc = sdk.token.parseFromUrl._getLocation();\n  if (nativeHistory && nativeHistory.replaceState) {\n    nativeHistory.replaceState(null, nativeDoc.title, nativeLoc.pathname + nativeLoc.search);\n  } else {\n    nativeLoc.hash = '';\n  }\n}\n\nfunction parseFromUrl(sdk, url) {\n  var nativeLoc = sdk.token.parseFromUrl._getLocation();\n  var hash = nativeLoc.hash;\n  if (url) {\n    hash = url.substring(url.indexOf('#'));\n  }\n\n  var oauthParamsCookie = cookies.getCookie(config.REDIRECT_OAUTH_PARAMS_COOKIE_NAME);\n  if (!hash || !oauthParamsCookie) {\n    return Q.reject(new AuthSdkError('Unable to parse a token from the url'));\n  }\n  try {\n    var oauthParams = JSON.parse(oauthParamsCookie);\n    var urls = oauthParams.urls;\n    delete oauthParams.urls;\n    cookies.deleteCookie(config.REDIRECT_OAUTH_PARAMS_COOKIE_NAME);\n  } catch(e) {\n    return Q.reject(new AuthSdkError('Unable to parse the ' + \n      config.REDIRECT_OAUTH_PARAMS_COOKIE_NAME + ' cookie: ' + e.message));\n  }\n\n  return Q.resolve(oauthUtil.hashToObject(hash))\n    .then(function(res) {\n      if (!url) {\n        // Remove the hash from the url\n        removeHash(sdk);\n      }\n      return handleOAuthResponse(sdk, oauthParams, res, urls);\n    });\n}\n\nfunction getUserInfo(sdk, accessTokenObject) {\n  if (!accessTokenObject ||\n      (!oauthUtil.isToken(accessTokenObject) && !accessTokenObject.accessToken && !accessTokenObject.userinfoUrl)) {\n    return Q.reject(new AuthSdkError('getUserInfo requires an access token object'));\n  }\n  return http.httpRequest(sdk, {\n    url: accessTokenObject.userinfoUrl,\n    method: 'GET',\n    accessToken: accessTokenObject.accessToken\n  })\n  .fail(function(err) {\n    if (err.xhr && (err.xhr.status === 401 || err.xhr.status === 403)) {\n      var authenticateHeader = err.xhr.getResponseHeader('WWW-Authenticate');\n      if (authenticateHeader) {\n        var errorMatches = authenticateHeader.match(/error=\"(.*?)\"/) || [];\n        var errorDescriptionMatches = authenticateHeader.match(/error_description=\"(.*?)\"/) || [];\n        var error = errorMatches[1];\n        var errorDescription = errorDescriptionMatches[1];\n        if (error && errorDescription) {\n          err = new OAuthError(error, errorDescription);\n        }\n      }\n    }\n    throw err;\n  });\n}\n\nmodule.exports = {\n  getToken: getToken,\n  getWithoutPrompt: getWithoutPrompt,\n  getWithPopup: getWithPopup,\n  getWithRedirect: getWithRedirect,\n  parseFromUrl: parseFromUrl,\n  refreshIdToken: refreshIdToken,\n  decodeToken: decodeToken,\n  verifyIdToken: verifyIdToken,\n  refreshToken: refreshToken,\n  getUserInfo: getUserInfo,\n  verifyToken: verifyToken\n};\n"]},"metadata":{},"sourceType":"script"}