{"ast":null,"code":"/* eslint-disable complexity, max-statements */\nvar http = require('./http');\n\nvar util = require('./util');\n\nvar storageUtil = require('./storageUtil');\n\nvar AuthSdkError = require('./errors/AuthSdkError');\n\nvar httpCache = storageUtil.getHttpCache();\n\nfunction isToken(obj) {\n  if (obj && (obj.accessToken || obj.idToken) && Array.isArray(obj.scopes)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction addListener(eventTarget, name, fn) {\n  if (eventTarget.addEventListener) {\n    eventTarget.addEventListener(name, fn);\n  } else {\n    eventTarget.attachEvent('on' + name, fn);\n  }\n}\n\nfunction removeListener(eventTarget, name, fn) {\n  if (eventTarget.removeEventListener) {\n    eventTarget.removeEventListener(name, fn);\n  } else {\n    eventTarget.detachEvent('on' + name, fn);\n  }\n}\n\nfunction loadFrame(src) {\n  var iframe = document.createElement('iframe');\n  iframe.style.display = 'none';\n  iframe.src = src;\n  return document.body.appendChild(iframe);\n}\n\nfunction loadPopup(src, options) {\n  var title = options.popupTitle || 'External Identity Provider User Authentication';\n  var appearance = 'toolbar=no, scrollbars=yes, resizable=yes, ' + 'top=100, left=500, width=600, height=600';\n\n  if (util.isIE11OrLess()) {\n    // IE<=11 doesn't fully support postMessage at time of writting.\n    // the following simple solution happened to solve the issue\n    // without adding another proxy layer which makes flow more complecated.\n    var winEl = window.open('/', title, appearance);\n    winEl.location.href = src;\n    return winEl;\n  } else {\n    return window.open(src, title, appearance);\n  }\n}\n\nfunction getWellKnown(sdk, issuer) {\n  return http.get(sdk, (issuer || sdk.options.url) + '/.well-known/openid-configuration', {\n    cacheResponse: true\n  });\n}\n\nfunction getKey(sdk, issuer, kid) {\n  return getWellKnown(sdk, issuer).then(function (wellKnown) {\n    var jwksUri = wellKnown['jwks_uri']; // Check our kid against the cached version (if it exists and isn't expired)\n\n    var cacheContents = httpCache.getStorage();\n    var cachedResponse = cacheContents[jwksUri];\n\n    if (cachedResponse && Date.now() / 1000 < cachedResponse.expiresAt) {\n      var cachedKey = util.find(cachedResponse.response.keys, {\n        kid: kid\n      });\n\n      if (cachedKey) {\n        return cachedKey;\n      }\n    } // Remove cache for the key\n\n\n    httpCache.clearStorage(jwksUri); // Pull the latest keys if the key wasn't in the cache\n\n    return http.get(sdk, jwksUri, {\n      cacheResponse: true\n    }).then(function (res) {\n      var key = util.find(res.keys, {\n        kid: kid\n      });\n\n      if (key) {\n        return key;\n      }\n\n      throw new AuthSdkError('The key id, ' + kid + ', was not found in the server\\'s keys');\n    });\n  });\n}\n\nfunction validateClaims(sdk, claims, aud, iss, nonce) {\n  if (!claims || !iss || !aud) {\n    throw new AuthSdkError('The jwt, iss, and aud arguments are all required');\n  }\n\n  if (nonce && claims.nonce !== nonce) {\n    throw new AuthSdkError('OAuth flow response nonce doesn\\'t match request nonce');\n  }\n\n  var now = Math.floor(new Date().getTime() / 1000);\n\n  if (claims.iss !== iss) {\n    throw new AuthSdkError('The issuer [' + claims.iss + '] ' + 'does not match [' + iss + ']');\n  }\n\n  if (claims.aud !== aud) {\n    throw new AuthSdkError('The audience [' + claims.aud + '] ' + 'does not match [' + aud + ']');\n  }\n\n  if (claims.iat > claims.exp) {\n    throw new AuthSdkError('The JWT expired before it was issued');\n  }\n\n  if (now - sdk.options.maxClockSkew > claims.exp) {\n    throw new AuthSdkError('The JWT expired and is no longer valid');\n  }\n\n  if (claims.iat > now + sdk.options.maxClockSkew) {\n    throw new AuthSdkError('The JWT was issued in the future');\n  }\n}\n\nfunction getOAuthUrls(sdk, oauthParams, options) {\n  options = options || {}; // Get user-supplied arguments\n\n  var authorizeUrl = util.removeTrailingSlash(options.authorizeUrl) || sdk.options.authorizeUrl;\n  var issuer = util.removeTrailingSlash(options.issuer) || sdk.options.issuer;\n  var userinfoUrl = util.removeTrailingSlash(options.userinfoUrl) || sdk.options.userinfoUrl; // If an issuer exists but it's not a url, assume it's an authServerId\n\n  if (issuer && !/^https?:/.test(issuer)) {\n    // Make it a url\n    issuer = sdk.options.url + '/oauth2/' + issuer;\n  } // If an authorizeUrl is supplied without an issuer, and an id_token is requested\n\n\n  if (!issuer && authorizeUrl && oauthParams.responseType.indexOf('id_token') !== -1) {\n    // The issuer is ambiguous, so we won't be able to validate the id_token jwt\n    throw new AuthSdkError('Cannot request idToken with an authorizeUrl without an issuer');\n  } // If a token is requested without an issuer\n\n\n  if (!issuer && oauthParams.responseType.indexOf('token') !== -1) {\n    // If an authorizeUrl is supplied without a userinfoUrl\n    if (authorizeUrl && !userinfoUrl) {\n      // The userinfoUrl is ambiguous, so we won't be able to call getUserInfo\n      throw new AuthSdkError('Cannot request accessToken with an authorizeUrl without an issuer or userinfoUrl');\n    } // If a userinfoUrl is supplied without a authorizeUrl\n\n\n    if (userinfoUrl && !authorizeUrl) {\n      // The authorizeUrl is ambiguous, so we won't be able to call the authorize endpoint\n      throw new AuthSdkError('Cannot request token with an userinfoUrl without an issuer or authorizeUrl');\n    }\n  }\n\n  var sharedResourceServerRegex = new RegExp('^https?://.*?/oauth2/.+'); // Default the issuer to our baseUrl\n\n  issuer = issuer || sdk.options.url; // A shared resource server issuer looks like:\n  // https://example.okta.com/oauth2/aus8aus76q8iphupD0h7\n\n  if (sharedResourceServerRegex.test(issuer)) {\n    // A shared resource server authorizeUrl looks like:\n    // https://example.okta.com/oauth2/aus8aus76q8iphupD0h7/v1/authorize\n    authorizeUrl = authorizeUrl || issuer + '/v1/authorize'; // Shared resource server userinfoUrls look like:\n    // https://example.okta.com/oauth2/aus8aus76q8iphupD0h7/v1/userinfo\n\n    userinfoUrl = userinfoUrl || issuer + '/v1/userinfo'; // Normally looks like:\n    // https://example.okta.com\n  } else {\n    // Normal authorizeUrls look like:\n    // https://example.okta.com/oauth2/v1/authorize\n    authorizeUrl = authorizeUrl || issuer + '/oauth2/v1/authorize'; // Normal userinfoUrls look like:\n    // https://example.okta.com/oauth2/v1/userinfo\n\n    userinfoUrl = userinfoUrl || issuer + '/oauth2/v1/userinfo';\n  }\n\n  return {\n    issuer: issuer,\n    authorizeUrl: authorizeUrl,\n    userinfoUrl: userinfoUrl\n  };\n}\n\nfunction hashToObject(hash) {\n  // Predefine regexs for parsing hash\n  var plus2space = /\\+/g;\n  var paramSplit = /([^&=]+)=?([^&]*)/g; // Remove the leading hash\n\n  var fragment = hash.substring(1);\n  var obj = {}; // Loop until we have no more params\n\n  var param;\n\n  while (true) {\n    // eslint-disable-line no-constant-condition\n    param = paramSplit.exec(fragment);\n\n    if (!param) {\n      break;\n    }\n\n    var key = param[1];\n    var value = param[2]; // id_token should remain base64url encoded\n\n    if (key === 'id_token' || key === 'access_token' || key === 'code') {\n      obj[key] = value;\n    } else {\n      obj[key] = decodeURIComponent(value.replace(plus2space, ' '));\n    }\n  }\n\n  return obj;\n}\n\nmodule.exports = {\n  getWellKnown: getWellKnown,\n  getKey: getKey,\n  validateClaims: validateClaims,\n  getOAuthUrls: getOAuthUrls,\n  loadFrame: loadFrame,\n  loadPopup: loadPopup,\n  hashToObject: hashToObject,\n  isToken: isToken,\n  addListener: addListener,\n  removeListener: removeListener\n};","map":{"version":3,"sources":["C:/Users/robin/Desktop/sso/my-app/node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/lib/oauthUtil.js"],"names":["http","require","util","storageUtil","AuthSdkError","httpCache","getHttpCache","isToken","obj","accessToken","idToken","Array","isArray","scopes","addListener","eventTarget","name","fn","addEventListener","attachEvent","removeListener","removeEventListener","detachEvent","loadFrame","src","iframe","document","createElement","style","display","body","appendChild","loadPopup","options","title","popupTitle","appearance","isIE11OrLess","winEl","window","open","location","href","getWellKnown","sdk","issuer","get","url","cacheResponse","getKey","kid","then","wellKnown","jwksUri","cacheContents","getStorage","cachedResponse","Date","now","expiresAt","cachedKey","find","response","keys","clearStorage","res","key","validateClaims","claims","aud","iss","nonce","Math","floor","getTime","iat","exp","maxClockSkew","getOAuthUrls","oauthParams","authorizeUrl","removeTrailingSlash","userinfoUrl","test","responseType","indexOf","sharedResourceServerRegex","RegExp","hashToObject","hash","plus2space","paramSplit","fragment","substring","param","exec","value","decodeURIComponent","replace","module","exports"],"mappings":"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","sourcesContent":["/* eslint-disable complexity, max-statements */\nvar http = require('./http');\nvar util = require('./util');\nvar storageUtil = require('./storageUtil');\nvar AuthSdkError = require('./errors/AuthSdkError');\n\nvar httpCache = storageUtil.getHttpCache();\n\nfunction isToken(obj) {\n  if (obj &&\n      (obj.accessToken || obj.idToken) &&\n      Array.isArray(obj.scopes)) {\n    return true;\n  }\n  return false;\n}\n\nfunction addListener(eventTarget, name, fn) {\n  if (eventTarget.addEventListener) {\n    eventTarget.addEventListener(name, fn);\n  } else {\n    eventTarget.attachEvent('on' + name, fn);\n  }\n}\n\nfunction removeListener(eventTarget, name, fn) {\n  if (eventTarget.removeEventListener) {\n    eventTarget.removeEventListener(name, fn);\n  } else {\n    eventTarget.detachEvent('on' + name, fn);\n  }\n}\n\nfunction loadFrame(src) {\n  var iframe = document.createElement('iframe');\n  iframe.style.display = 'none';\n  iframe.src = src;\n\n  return document.body.appendChild(iframe);\n}\n\nfunction loadPopup(src, options) {\n  var title = options.popupTitle || 'External Identity Provider User Authentication';\n  var appearance = 'toolbar=no, scrollbars=yes, resizable=yes, ' +\n    'top=100, left=500, width=600, height=600';\n\n  if (util.isIE11OrLess()) {\n    // IE<=11 doesn't fully support postMessage at time of writting.\n    // the following simple solution happened to solve the issue\n    // without adding another proxy layer which makes flow more complecated.\n    var winEl = window.open('/', title, appearance);\n    winEl.location.href = src;\n    return winEl;\n  } else {\n    return window.open(src, title, appearance);\n  }\n}\n\nfunction getWellKnown(sdk, issuer) {\n  return http.get(sdk, (issuer || sdk.options.url) + '/.well-known/openid-configuration', {\n    cacheResponse: true\n  });\n}\n\nfunction getKey(sdk, issuer, kid) {\n  return getWellKnown(sdk, issuer)\n  .then(function(wellKnown) {\n    var jwksUri = wellKnown['jwks_uri'];\n\n    // Check our kid against the cached version (if it exists and isn't expired)\n    var cacheContents = httpCache.getStorage();\n    var cachedResponse = cacheContents[jwksUri];\n    if (cachedResponse && Date.now()/1000 < cachedResponse.expiresAt) {\n      var cachedKey = util.find(cachedResponse.response.keys, {\n        kid: kid\n      });\n\n      if (cachedKey) {\n        return cachedKey;\n      }\n    }\n\n    // Remove cache for the key\n    httpCache.clearStorage(jwksUri);\n\n    // Pull the latest keys if the key wasn't in the cache\n    return http.get(sdk, jwksUri, {\n      cacheResponse: true\n    })\n    .then(function(res) {\n      var key = util.find(res.keys, {\n        kid: kid\n      });\n\n      if (key) {\n        return key;\n      }\n\n      throw new AuthSdkError('The key id, ' + kid + ', was not found in the server\\'s keys');\n    });\n  });\n}\n\nfunction validateClaims(sdk, claims, aud, iss, nonce) {\n  if (!claims || !iss || !aud) {\n    throw new AuthSdkError('The jwt, iss, and aud arguments are all required');\n  }\n\n  if (nonce && claims.nonce !== nonce) {\n    throw new AuthSdkError('OAuth flow response nonce doesn\\'t match request nonce');\n  }\n\n  var now = Math.floor(new Date().getTime()/1000);\n\n  if (claims.iss !== iss) {\n    throw new AuthSdkError('The issuer [' + claims.iss + '] ' +\n      'does not match [' + iss + ']');\n  }\n\n  if (claims.aud !== aud) {\n    throw new AuthSdkError('The audience [' + claims.aud + '] ' +\n      'does not match [' + aud + ']');\n  }\n\n  if (claims.iat > claims.exp) {\n    throw new AuthSdkError('The JWT expired before it was issued');\n  }\n\n  if ((now - sdk.options.maxClockSkew) > claims.exp) {\n    throw new AuthSdkError('The JWT expired and is no longer valid');\n  }\n\n  if (claims.iat > (now + sdk.options.maxClockSkew)) {\n    throw new AuthSdkError('The JWT was issued in the future');\n  }\n}\n\nfunction getOAuthUrls(sdk, oauthParams, options) {\n  options = options || {};\n\n  // Get user-supplied arguments\n  var authorizeUrl = util.removeTrailingSlash(options.authorizeUrl) || sdk.options.authorizeUrl;\n  var issuer = util.removeTrailingSlash(options.issuer) || sdk.options.issuer;\n  var userinfoUrl = util.removeTrailingSlash(options.userinfoUrl) || sdk.options.userinfoUrl;\n\n  // If an issuer exists but it's not a url, assume it's an authServerId\n  if (issuer && !(/^https?:/.test(issuer))) {\n    // Make it a url\n    issuer = sdk.options.url + '/oauth2/' + issuer;\n  }\n\n  // If an authorizeUrl is supplied without an issuer, and an id_token is requested\n  if (!issuer && authorizeUrl &&\n      oauthParams.responseType.indexOf('id_token') !== -1) {\n    // The issuer is ambiguous, so we won't be able to validate the id_token jwt\n    throw new AuthSdkError('Cannot request idToken with an authorizeUrl without an issuer');\n  }\n\n  // If a token is requested without an issuer\n  if (!issuer && oauthParams.responseType.indexOf('token') !== -1) {\n    // If an authorizeUrl is supplied without a userinfoUrl\n    if (authorizeUrl && !userinfoUrl) {\n      // The userinfoUrl is ambiguous, so we won't be able to call getUserInfo\n      throw new AuthSdkError('Cannot request accessToken with an authorizeUrl without an issuer or userinfoUrl');\n    }\n\n    // If a userinfoUrl is supplied without a authorizeUrl\n    if (userinfoUrl && !authorizeUrl) {\n      // The authorizeUrl is ambiguous, so we won't be able to call the authorize endpoint\n      throw new AuthSdkError('Cannot request token with an userinfoUrl without an issuer or authorizeUrl');\n    }\n  }\n\n  var sharedResourceServerRegex = new RegExp('^https?://.*?/oauth2/.+');\n\n  // Default the issuer to our baseUrl\n  issuer = issuer || sdk.options.url;\n\n  // A shared resource server issuer looks like:\n  // https://example.okta.com/oauth2/aus8aus76q8iphupD0h7\n  if (sharedResourceServerRegex.test(issuer)) {\n    // A shared resource server authorizeUrl looks like:\n    // https://example.okta.com/oauth2/aus8aus76q8iphupD0h7/v1/authorize\n    authorizeUrl = authorizeUrl || issuer + '/v1/authorize';\n    // Shared resource server userinfoUrls look like:\n    // https://example.okta.com/oauth2/aus8aus76q8iphupD0h7/v1/userinfo\n    userinfoUrl = userinfoUrl || issuer + '/v1/userinfo';\n\n  // Normally looks like:\n  // https://example.okta.com\n  } else {\n    // Normal authorizeUrls look like:\n    // https://example.okta.com/oauth2/v1/authorize\n    authorizeUrl = authorizeUrl || issuer + '/oauth2/v1/authorize';\n    // Normal userinfoUrls look like:\n    // https://example.okta.com/oauth2/v1/userinfo\n    userinfoUrl = userinfoUrl || issuer + '/oauth2/v1/userinfo';\n  }\n\n  return {\n    issuer: issuer,\n    authorizeUrl: authorizeUrl,\n    userinfoUrl: userinfoUrl\n  };\n}\n\nfunction hashToObject(hash) {\n  // Predefine regexs for parsing hash\n  var plus2space = /\\+/g;\n  var paramSplit = /([^&=]+)=?([^&]*)/g;\n\n  // Remove the leading hash\n  var fragment = hash.substring(1);\n\n  var obj = {};\n\n  // Loop until we have no more params\n  var param;\n  while (true) { // eslint-disable-line no-constant-condition\n    param = paramSplit.exec(fragment);\n    if (!param) { break; }\n\n    var key = param[1];\n    var value = param[2];\n\n    // id_token should remain base64url encoded\n    if (key === 'id_token' || key === 'access_token' || key === 'code') {\n      obj[key] = value;\n    } else {\n      obj[key] = decodeURIComponent(value.replace(plus2space, ' '));\n    }\n  }\n  return obj;\n}\n\nmodule.exports = {\n  getWellKnown: getWellKnown,\n  getKey: getKey,\n  validateClaims: validateClaims,\n  getOAuthUrls: getOAuthUrls,\n  loadFrame: loadFrame,\n  loadPopup: loadPopup,\n  hashToObject: hashToObject,\n  isToken: isToken,\n  addListener: addListener,\n  removeListener: removeListener\n};\n"]},"metadata":{},"sourceType":"script"}