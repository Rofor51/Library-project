{"ast":null,"code":"/* eslint-disable complexity, max-statements */\nvar http = require('./http');\n\nvar util = require('./util');\n\nvar Q = require('q');\n\nvar AuthSdkError = require('./errors/AuthSdkError');\n\nvar AuthPollStopError = require('./errors/AuthPollStopError');\n\nvar config = require('./config');\n\nfunction addStateToken(res, options) {\n  var builtArgs = {};\n  util.extend(builtArgs, options); // Add the stateToken if one isn't passed and we have one\n\n  if (!builtArgs.stateToken && res.stateToken) {\n    builtArgs.stateToken = res.stateToken;\n  }\n\n  return builtArgs;\n}\n\nfunction getStateToken(res) {\n  return addStateToken(res);\n}\n\nfunction transactionStatus(sdk, args) {\n  args = addStateToken(sdk, args);\n  return http.post(sdk, sdk.options.url + '/api/v1/authn', args);\n}\n\nfunction resumeTransaction(sdk, args) {\n  if (!args || !args.stateToken) {\n    var stateToken = sdk.tx.exists._getCookie(config.STATE_TOKEN_COOKIE_NAME);\n\n    if (stateToken) {\n      args = {\n        stateToken: stateToken\n      };\n    } else {\n      return Q.reject(new AuthSdkError('No transaction to resume'));\n    }\n  }\n\n  return sdk.tx.status(args).then(function (res) {\n    return new AuthTransaction(sdk, res);\n  });\n}\n\nfunction transactionExists(sdk) {\n  // We have a cookie state token\n  return !!sdk.tx.exists._getCookie(config.STATE_TOKEN_COOKIE_NAME);\n}\n\nfunction postToTransaction(sdk, url, args, options) {\n  return http.post(sdk, url, args, options).then(function (res) {\n    return new AuthTransaction(sdk, res);\n  });\n}\n\nfunction getPollFn(sdk, res, ref) {\n  return function (options) {\n    var delay;\n    var rememberDevice;\n    var autoPush;\n\n    if (util.isNumber(options)) {\n      delay = options;\n    } else if (util.isObject(options)) {\n      delay = options.delay;\n      rememberDevice = options.rememberDevice;\n      autoPush = options.autoPush;\n    }\n\n    if (!delay && delay !== 0) {\n      delay = config.DEFAULT_POLLING_DELAY;\n    } // Get the poll function\n\n\n    var pollLink = util.getLink(res, 'next', 'poll');\n\n    function pollFn() {\n      var opts = {};\n\n      if (typeof autoPush === 'function') {\n        try {\n          opts.autoPush = !!autoPush();\n        } catch (e) {\n          return Q.reject(new AuthSdkError('AutoPush resulted in an error.'));\n        }\n      } else if (autoPush !== undefined && autoPush !== null) {\n        opts.autoPush = !!autoPush;\n      }\n\n      if (typeof rememberDevice === 'function') {\n        try {\n          opts.rememberDevice = !!rememberDevice();\n        } catch (e) {\n          return Q.reject(new AuthSdkError('RememberDevice resulted in an error.'));\n        }\n      } else if (rememberDevice !== undefined && rememberDevice !== null) {\n        opts.rememberDevice = !!rememberDevice;\n      }\n\n      var href = pollLink.href + util.toQueryParams(opts);\n      return http.post(sdk, href, getStateToken(res), {\n        saveAuthnState: false\n      });\n    }\n\n    ref.isPolling = true;\n    var retryCount = 0;\n\n    var recursivePoll = function recursivePoll() {\n      // If the poll was manually stopped during the delay\n      if (!ref.isPolling) {\n        return Q.reject(new AuthPollStopError());\n      }\n\n      return pollFn().then(function (pollRes) {\n        // Reset our retry counter on success\n        retryCount = 0; // If we're still waiting\n\n        if (pollRes.factorResult && pollRes.factorResult === 'WAITING') {\n          // If the poll was manually stopped while the pollFn was called\n          if (!ref.isPolling) {\n            throw new AuthPollStopError();\n          } // Continue poll\n\n\n          return Q.delay(delay).then(recursivePoll);\n        } else {\n          // Any non-waiting result, even if polling was stopped\n          // during a request, will return\n          ref.isPolling = false;\n          return new AuthTransaction(sdk, pollRes);\n        }\n      }).fail(function (err) {\n        // Exponential backoff, up to 16 seconds\n        if (err.xhr && (err.xhr.status === 0 || err.xhr.status === 429) && retryCount <= 4) {\n          var delayLength = Math.pow(2, retryCount) * 1000;\n          retryCount++;\n          return Q.delay(delayLength).then(recursivePoll);\n        }\n\n        throw err;\n      });\n    };\n\n    return recursivePoll().fail(function (err) {\n      ref.isPolling = false;\n      throw err;\n    });\n  };\n}\n\nfunction link2fn(sdk, res, obj, link, ref) {\n  if (Array.isArray(link)) {\n    return function (name, opts) {\n      if (!name) {\n        throw new AuthSdkError('Must provide a link name');\n      }\n\n      var lk = util.find(link, {\n        name: name\n      });\n\n      if (!lk) {\n        throw new AuthSdkError('No link found for that name');\n      }\n\n      return link2fn(sdk, res, obj, lk, ref)(opts);\n    };\n  } else if (link.hints && link.hints.allow && link.hints.allow.length === 1) {\n    var method = link.hints.allow[0];\n\n    switch (method) {\n      case 'GET':\n        return function () {\n          return http.get(sdk, link.href);\n        };\n\n      case 'POST':\n        return function (opts) {\n          if (ref && ref.isPolling) {\n            ref.isPolling = false;\n          }\n\n          var data = addStateToken(res, opts);\n\n          if (res.status === 'MFA_ENROLL' || res.status === 'FACTOR_ENROLL') {\n            // Add factorType and provider\n            util.extend(data, {\n              factorType: obj.factorType,\n              provider: obj.provider\n            });\n          }\n\n          var params = {};\n          var autoPush = data.autoPush;\n\n          if (autoPush !== undefined) {\n            if (typeof autoPush === 'function') {\n              try {\n                params.autoPush = !!autoPush();\n              } catch (e) {\n                return Q.reject(new AuthSdkError('AutoPush resulted in an error.'));\n              }\n            } else if (autoPush !== null) {\n              params.autoPush = !!autoPush;\n            }\n\n            data = util.omit(data, 'autoPush');\n          }\n\n          var rememberDevice = data.rememberDevice;\n\n          if (rememberDevice !== undefined) {\n            if (typeof rememberDevice === 'function') {\n              try {\n                params.rememberDevice = !!rememberDevice();\n              } catch (e) {\n                return Q.reject(new AuthSdkError('RememberDevice resulted in an error.'));\n              }\n            } else if (rememberDevice !== null) {\n              params.rememberDevice = !!rememberDevice;\n            }\n\n            data = util.omit(data, 'rememberDevice');\n          } else if (data.profile && data.profile.updatePhone !== undefined) {\n            if (data.profile.updatePhone) {\n              params.updatePhone = true;\n            }\n\n            data.profile = util.omit(data.profile, 'updatePhone');\n          }\n\n          var href = link.href + util.toQueryParams(params);\n          return postToTransaction(sdk, href, data);\n        };\n    }\n  }\n}\n\nfunction links2fns(sdk, res, obj, ref) {\n  var fns = {};\n\n  for (var linkName in obj._links) {\n    if (!obj._links.hasOwnProperty(linkName)) {\n      continue;\n    }\n\n    var link = obj._links[linkName];\n\n    if (linkName === 'next') {\n      linkName = link.name;\n    }\n\n    if (link.type) {\n      fns[linkName] = link;\n      continue;\n    }\n\n    switch (linkName) {\n      // poll is only found at the transaction\n      // level, so we don't need to pass the link\n      case 'poll':\n        fns.poll = getPollFn(sdk, res, ref);\n        break;\n\n      default:\n        var fn = link2fn(sdk, res, obj, link, ref);\n\n        if (fn) {\n          fns[linkName] = fn;\n        }\n\n    }\n  }\n\n  return fns;\n}\n\nfunction flattenEmbedded(sdk, res, obj, ref) {\n  obj = obj || res;\n  obj = util.clone(obj);\n\n  if (Array.isArray(obj)) {\n    var objArr = [];\n\n    for (var o = 0, ol = obj.length; o < ol; o++) {\n      objArr.push(flattenEmbedded(sdk, res, obj[o], ref));\n    }\n\n    return objArr;\n  }\n\n  var embedded = obj._embedded || {};\n\n  for (var key in embedded) {\n    if (!embedded.hasOwnProperty(key)) {\n      continue;\n    } // Flatten any nested _embedded objects\n\n\n    if (util.isObject(embedded[key]) || Array.isArray(embedded[key])) {\n      embedded[key] = flattenEmbedded(sdk, res, embedded[key], ref);\n    }\n  } // Convert any links on the embedded object\n\n\n  var fns = links2fns(sdk, res, obj, ref);\n  util.extend(embedded, fns);\n  obj = util.omit(obj, '_embedded', '_links');\n  util.extend(obj, embedded);\n  return obj;\n}\n\nfunction AuthTransaction(sdk, res) {\n  if (res) {\n    this.data = res;\n    util.extend(this, flattenEmbedded(sdk, res, res, {}));\n    delete this.stateToken; // RECOVERY_CHALLENGE has some responses without _links.\n    // Without _links, we emulate cancel to make it intuitive\n    // to return to the starting state. We may remove this\n    // when OKTA-75434 is resolved\n\n    if (res.status === 'RECOVERY_CHALLENGE' && !res._links) {\n      this.cancel = function () {\n        return new Q(new AuthTransaction(sdk));\n      };\n    }\n  }\n}\n\nmodule.exports = {\n  transactionStatus: transactionStatus,\n  resumeTransaction: resumeTransaction,\n  transactionExists: transactionExists,\n  postToTransaction: postToTransaction\n};","map":{"version":3,"sources":["C:/Users/robin/Desktop/Library/Library-React/my-app/node_modules/@okta/okta-signin-widget/node_modules/@okta/okta-auth-js/lib/tx.js"],"names":["http","require","util","Q","AuthSdkError","AuthPollStopError","config","addStateToken","res","options","builtArgs","extend","stateToken","getStateToken","transactionStatus","sdk","args","post","url","resumeTransaction","tx","exists","_getCookie","STATE_TOKEN_COOKIE_NAME","reject","status","then","AuthTransaction","transactionExists","postToTransaction","getPollFn","ref","delay","rememberDevice","autoPush","isNumber","isObject","DEFAULT_POLLING_DELAY","pollLink","getLink","pollFn","opts","e","undefined","href","toQueryParams","saveAuthnState","isPolling","retryCount","recursivePoll","pollRes","factorResult","fail","err","xhr","delayLength","Math","pow","link2fn","obj","link","Array","isArray","name","lk","find","hints","allow","length","method","get","data","factorType","provider","params","omit","profile","updatePhone","links2fns","fns","linkName","_links","hasOwnProperty","type","poll","fn","flattenEmbedded","clone","objArr","o","ol","push","embedded","_embedded","key","cancel","module","exports"],"mappings":"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","sourcesContent":["/* eslint-disable complexity, max-statements */\nvar http              = require('./http');\nvar util              = require('./util');\nvar Q                 = require('q');\nvar AuthSdkError      = require('./errors/AuthSdkError');\nvar AuthPollStopError = require('./errors/AuthPollStopError');\nvar config            = require('./config');\n\nfunction addStateToken(res, options) {\n  var builtArgs = {};\n  util.extend(builtArgs, options);\n\n  // Add the stateToken if one isn't passed and we have one\n  if (!builtArgs.stateToken && res.stateToken) {\n    builtArgs.stateToken = res.stateToken;\n  }\n\n  return builtArgs;\n}\n\nfunction getStateToken(res) {\n  return addStateToken(res);\n}\n\nfunction transactionStatus(sdk, args) {\n  args = addStateToken(sdk, args);\n  return http.post(sdk, sdk.options.url + '/api/v1/authn', args);\n}\n\nfunction resumeTransaction(sdk, args) {\n  if (!args || !args.stateToken) {\n    var stateToken = sdk.tx.exists._getCookie(config.STATE_TOKEN_COOKIE_NAME);\n    if (stateToken) {\n      args = {\n        stateToken: stateToken\n      };\n    } else {\n      return Q.reject(new AuthSdkError('No transaction to resume'));\n    }\n  }\n  return sdk.tx.status(args)\n    .then(function(res) {\n      return new AuthTransaction(sdk, res);\n    });\n}\n\nfunction transactionExists(sdk) {\n  // We have a cookie state token\n  return !!sdk.tx.exists._getCookie(config.STATE_TOKEN_COOKIE_NAME);\n}\n\nfunction postToTransaction(sdk, url, args, options) {\n  return http.post(sdk, url, args, options)\n    .then(function(res) {\n      return new AuthTransaction(sdk, res);\n    });\n}\n\nfunction getPollFn(sdk, res, ref) {\n  return function (options) {\n    var delay;\n    var rememberDevice;\n    var autoPush;\n\n    if (util.isNumber(options)) {\n      delay = options;\n    } else if (util.isObject(options)) {\n      delay = options.delay;\n      rememberDevice = options.rememberDevice;\n      autoPush = options.autoPush;\n    }\n\n    if (!delay && delay !== 0) {\n      delay = config.DEFAULT_POLLING_DELAY;\n    }\n\n    // Get the poll function\n    var pollLink = util.getLink(res, 'next', 'poll');\n    function pollFn() {\n      var opts = {};\n      if (typeof autoPush === 'function') {\n        try {\n          opts.autoPush = !!autoPush();\n        }\n        catch (e) {\n          return Q.reject(new AuthSdkError('AutoPush resulted in an error.'));\n        }\n      }\n      else if (autoPush !== undefined && autoPush !== null) {\n        opts.autoPush = !!autoPush;\n      }\n      if (typeof rememberDevice === 'function') {\n        try {\n          opts.rememberDevice = !!rememberDevice();\n        }\n        catch (e) {\n          return Q.reject(new AuthSdkError('RememberDevice resulted in an error.'));\n        }\n      }\n      else if (rememberDevice !== undefined && rememberDevice !== null) {\n        opts.rememberDevice = !!rememberDevice;\n      }\n\n      var href = pollLink.href + util.toQueryParams(opts);\n      return http.post(sdk, href, getStateToken(res), {\n        saveAuthnState: false  \n      });\n    }\n\n    ref.isPolling = true;\n\n    var retryCount = 0;\n    var recursivePoll = function () {\n      // If the poll was manually stopped during the delay\n      if (!ref.isPolling) {\n        return Q.reject(new AuthPollStopError());\n      }\n      return pollFn()\n        .then(function (pollRes) {\n          // Reset our retry counter on success\n          retryCount = 0;\n\n          // If we're still waiting\n          if (pollRes.factorResult && pollRes.factorResult === 'WAITING') {\n\n            // If the poll was manually stopped while the pollFn was called\n            if (!ref.isPolling) {\n              throw new AuthPollStopError();\n            }\n\n            // Continue poll\n            return Q.delay(delay)\n              .then(recursivePoll);\n\n          } else {\n            // Any non-waiting result, even if polling was stopped\n            // during a request, will return\n            ref.isPolling = false;\n            return new AuthTransaction(sdk, pollRes);\n          }\n        })\n        .fail(function(err) {\n          // Exponential backoff, up to 16 seconds\n          if (err.xhr &&\n              (err.xhr.status === 0 || err.xhr.status === 429) &&\n              retryCount <= 4) {\n            var delayLength = Math.pow(2, retryCount) * 1000;\n            retryCount++;\n            return Q.delay(delayLength)\n              .then(recursivePoll);\n          }\n          throw err;\n        });\n    };\n    return recursivePoll()\n      .fail(function(err) {\n        ref.isPolling = false;\n        throw err;\n      });\n  };\n}\n\nfunction link2fn(sdk, res, obj, link, ref) {\n  if (Array.isArray(link)) {\n    return function(name, opts) {\n      if (!name) {\n        throw new AuthSdkError('Must provide a link name');\n      }\n\n      var lk = util.find(link, {name: name});\n      if (!lk) {\n        throw new AuthSdkError('No link found for that name');\n      }\n\n      return link2fn(sdk, res, obj, lk, ref)(opts);\n    };\n\n  } else if (link.hints &&\n      link.hints.allow &&\n      link.hints.allow.length === 1) {\n    var method = link.hints.allow[0];\n    switch (method) {\n\n      case 'GET':\n        return function() {\n          return http.get(sdk, link.href);\n        };\n\n      case 'POST':\n        return function(opts) {\n          if (ref && ref.isPolling) {\n            ref.isPolling = false;\n          }\n\n          var data = addStateToken(res, opts);\n\n          if (res.status === 'MFA_ENROLL' || res.status === 'FACTOR_ENROLL') {\n            // Add factorType and provider\n            util.extend(data, {\n              factorType: obj.factorType,\n              provider: obj.provider\n            });\n          }\n\n          var params = {};\n          var autoPush = data.autoPush;\n          if (autoPush !== undefined) {\n            if (typeof autoPush === 'function') {\n              try {\n                params.autoPush = !!autoPush();\n              }\n              catch (e) {\n                return Q.reject(new AuthSdkError('AutoPush resulted in an error.'));\n              }\n            }\n            else if (autoPush !== null) {\n              params.autoPush = !!autoPush;\n            }\n            data = util.omit(data, 'autoPush');\n          }\n\n          var rememberDevice = data.rememberDevice;\n          if (rememberDevice !== undefined) {\n            if (typeof rememberDevice === 'function') {\n              try {\n                params.rememberDevice = !!rememberDevice();\n              }\n              catch (e) {\n                return Q.reject(new AuthSdkError('RememberDevice resulted in an error.'));\n              }\n            }\n            else if (rememberDevice !== null) {\n              params.rememberDevice = !!rememberDevice;\n            }\n            data = util.omit(data, 'rememberDevice');\n\n          } else if (data.profile &&\n                    data.profile.updatePhone !== undefined) {\n            if (data.profile.updatePhone) {\n              params.updatePhone = true;\n            }\n            data.profile = util.omit(data.profile, 'updatePhone');\n          }\n          var href = link.href + util.toQueryParams(params);\n          return postToTransaction(sdk, href, data);\n        };\n    }\n  }\n}\n\nfunction links2fns(sdk, res, obj, ref) {\n  var fns = {};\n  for (var linkName in obj._links) {\n    if (!obj._links.hasOwnProperty(linkName)) {\n      continue;\n    }\n\n    var link = obj._links[linkName];\n    \n    if (linkName === 'next') {\n      linkName = link.name;\n    }\n\n    if (link.type) {\n      fns[linkName] = link;\n      continue;\n    }\n\n    switch (linkName) {\n      // poll is only found at the transaction\n      // level, so we don't need to pass the link\n      case 'poll':\n        fns.poll = getPollFn(sdk, res, ref);\n        break;\n\n      default:\n        var fn = link2fn(sdk, res, obj, link, ref);\n        if (fn) {\n          fns[linkName] = fn;\n        }\n    }\n  }\n  return fns;\n}\n\nfunction flattenEmbedded(sdk, res, obj, ref) {\n  obj = obj || res;\n  obj = util.clone(obj);\n\n  if (Array.isArray(obj)) {\n    var objArr = [];\n    for (var o = 0, ol = obj.length; o < ol; o++) {\n      objArr.push(flattenEmbedded(sdk, res, obj[o], ref));\n    }\n    return objArr;\n  }\n\n  var embedded = obj._embedded || {};\n\n  for (var key in embedded) {\n    if (!embedded.hasOwnProperty(key)) {\n      continue;\n    }\n\n    // Flatten any nested _embedded objects\n    if (util.isObject(embedded[key]) || Array.isArray(embedded[key])) {\n      embedded[key] = flattenEmbedded(sdk, res, embedded[key], ref);\n    }\n  }\n\n  // Convert any links on the embedded object\n  var fns = links2fns(sdk, res, obj, ref);\n  util.extend(embedded, fns);\n\n  obj = util.omit(obj, '_embedded', '_links');\n  util.extend(obj, embedded);\n  return obj;\n}\n\nfunction AuthTransaction(sdk, res) {\n  if (res) {\n    this.data = res;\n    util.extend(this, flattenEmbedded(sdk, res, res, {}));\n    delete this.stateToken;\n\n    // RECOVERY_CHALLENGE has some responses without _links.\n    // Without _links, we emulate cancel to make it intuitive\n    // to return to the starting state. We may remove this\n    // when OKTA-75434 is resolved\n    if (res.status === 'RECOVERY_CHALLENGE' && !res._links) {\n      this.cancel = function() {\n        return new Q(new AuthTransaction(sdk));\n      };\n    }\n  }\n}\n\nmodule.exports = {\n  transactionStatus: transactionStatus,\n  resumeTransaction: resumeTransaction,\n  transactionExists: transactionExists,\n  postToTransaction: postToTransaction\n};\n"]},"metadata":{},"sourceType":"script"}